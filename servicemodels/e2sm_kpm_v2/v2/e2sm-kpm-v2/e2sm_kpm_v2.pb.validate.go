// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: e2sm_kpm_v2/v2/e2sm_kpm_v2.proto

package e2sm_kpm_v2

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
)

// Validate checks the field values on Eutracgi with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Eutracgi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Eutracgi with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EutracgiMultiError, or nil
// if none found.
func (m *Eutracgi) ValidateAll() error {
	return m.validate(true)
}

func (m *Eutracgi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPLmnIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EutracgiValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EutracgiValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPLmnIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EutracgiValidationError{
				field:  "PLmnIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEUtracellIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EutracgiValidationError{
					field:  "EUtracellIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EutracgiValidationError{
					field:  "EUtracellIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEUtracellIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EutracgiValidationError{
				field:  "EUtracellIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EutracgiMultiError(errors)
	}
	return nil
}

// EutracgiMultiError is an error wrapping multiple validation errors returned
// by Eutracgi.ValidateAll() if the designated constraints aren't met.
type EutracgiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EutracgiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EutracgiMultiError) AllErrors() []error { return m }

// EutracgiValidationError is the validation error returned by
// Eutracgi.Validate if the designated constraints aren't met.
type EutracgiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EutracgiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EutracgiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EutracgiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EutracgiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EutracgiValidationError) ErrorName() string { return "EutracgiValidationError" }

// Error satisfies the builtin error interface
func (e EutracgiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEutracgi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EutracgiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EutracgiValidationError{}

// Validate checks the field values on Nrcgi with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Nrcgi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Nrcgi with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NrcgiMultiError, or nil if none found.
func (m *Nrcgi) ValidateAll() error {
	return m.validate(true)
}

func (m *Nrcgi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPLmnIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NrcgiValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NrcgiValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPLmnIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NrcgiValidationError{
				field:  "PLmnIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNRcellIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NrcgiValidationError{
					field:  "NRcellIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NrcgiValidationError{
					field:  "NRcellIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNRcellIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NrcgiValidationError{
				field:  "NRcellIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NrcgiMultiError(errors)
	}
	return nil
}

// NrcgiMultiError is an error wrapping multiple validation errors returned by
// Nrcgi.ValidateAll() if the designated constraints aren't met.
type NrcgiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NrcgiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NrcgiMultiError) AllErrors() []error { return m }

// NrcgiValidationError is the validation error returned by Nrcgi.Validate if
// the designated constraints aren't met.
type NrcgiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NrcgiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NrcgiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NrcgiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NrcgiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NrcgiValidationError) ErrorName() string { return "NrcgiValidationError" }

// Error satisfies the builtin error interface
func (e NrcgiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNrcgi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NrcgiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NrcgiValidationError{}

// Validate checks the field values on CellGlobalId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CellGlobalId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellGlobalId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CellGlobalIdMultiError, or
// nil if none found.
func (m *CellGlobalId) ValidateAll() error {
	return m.validate(true)
}

func (m *CellGlobalId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.CellGlobalId.(type) {

	case *CellGlobalId_NrCgi:

		if all {
			switch v := interface{}(m.GetNrCgi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CellGlobalIdValidationError{
						field:  "NrCgi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CellGlobalIdValidationError{
						field:  "NrCgi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNrCgi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CellGlobalIdValidationError{
					field:  "NrCgi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CellGlobalId_EUtraCgi:

		if all {
			switch v := interface{}(m.GetEUtraCgi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CellGlobalIdValidationError{
						field:  "EUtraCgi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CellGlobalIdValidationError{
						field:  "EUtraCgi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEUtraCgi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CellGlobalIdValidationError{
					field:  "EUtraCgi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CellGlobalIdMultiError(errors)
	}
	return nil
}

// CellGlobalIdMultiError is an error wrapping multiple validation errors
// returned by CellGlobalId.ValidateAll() if the designated constraints aren't met.
type CellGlobalIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellGlobalIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellGlobalIdMultiError) AllErrors() []error { return m }

// CellGlobalIdValidationError is the validation error returned by
// CellGlobalId.Validate if the designated constraints aren't met.
type CellGlobalIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellGlobalIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellGlobalIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellGlobalIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellGlobalIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellGlobalIdValidationError) ErrorName() string { return "CellGlobalIdValidationError" }

// Error satisfies the builtin error interface
func (e CellGlobalIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellGlobalId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellGlobalIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellGlobalIdValidationError{}

// Validate checks the field values on Snssai with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Snssai) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Snssai with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SnssaiMultiError, or nil if none found.
func (m *Snssai) ValidateAll() error {
	return m.validate(true)
}

func (m *Snssai) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSSt()) != 1 {
		err := SnssaiValidationError{
			field:  "SSt",
			reason: "value length must be 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetSD()) != 3 {
		err := SnssaiValidationError{
			field:  "SD",
			reason: "value length must be 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SnssaiMultiError(errors)
	}
	return nil
}

// SnssaiMultiError is an error wrapping multiple validation errors returned by
// Snssai.ValidateAll() if the designated constraints aren't met.
type SnssaiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnssaiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnssaiMultiError) AllErrors() []error { return m }

// SnssaiValidationError is the validation error returned by Snssai.Validate if
// the designated constraints aren't met.
type SnssaiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnssaiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnssaiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnssaiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnssaiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnssaiValidationError) ErrorName() string { return "SnssaiValidationError" }

// Error satisfies the builtin error interface
func (e SnssaiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnssai.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnssaiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnssaiValidationError{}

// Validate checks the field values on FiveQi with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FiveQi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FiveQi with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FiveQiMultiError, or nil if none found.
func (m *FiveQi) ValidateAll() error {
	return m.validate(true)
}

func (m *FiveQi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := FiveQiValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return FiveQiMultiError(errors)
	}
	return nil
}

// FiveQiMultiError is an error wrapping multiple validation errors returned by
// FiveQi.ValidateAll() if the designated constraints aren't met.
type FiveQiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FiveQiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FiveQiMultiError) AllErrors() []error { return m }

// FiveQiValidationError is the validation error returned by FiveQi.Validate if
// the designated constraints aren't met.
type FiveQiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FiveQiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FiveQiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FiveQiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FiveQiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FiveQiValidationError) ErrorName() string { return "FiveQiValidationError" }

// Error satisfies the builtin error interface
func (e FiveQiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFiveQi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FiveQiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FiveQiValidationError{}

// Validate checks the field values on Qci with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Qci) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Qci with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QciMultiError, or nil if none found.
func (m *Qci) ValidateAll() error {
	return m.validate(true)
}

func (m *Qci) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := QciValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QciMultiError(errors)
	}
	return nil
}

// QciMultiError is an error wrapping multiple validation errors returned by
// Qci.ValidateAll() if the designated constraints aren't met.
type QciMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QciMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QciMultiError) AllErrors() []error { return m }

// QciValidationError is the validation error returned by Qci.Validate if the
// designated constraints aren't met.
type QciValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QciValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QciValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QciValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QciValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QciValidationError) ErrorName() string { return "QciValidationError" }

// Error satisfies the builtin error interface
func (e QciValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQci.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QciValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QciValidationError{}

// Validate checks the field values on Qfi with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Qfi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Qfi with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QfiMultiError, or nil if none found.
func (m *Qfi) ValidateAll() error {
	return m.validate(true)
}

func (m *Qfi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 63 {
		err := QfiValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 63]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QfiMultiError(errors)
	}
	return nil
}

// QfiMultiError is an error wrapping multiple validation errors returned by
// Qfi.ValidateAll() if the designated constraints aren't met.
type QfiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QfiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QfiMultiError) AllErrors() []error { return m }

// QfiValidationError is the validation error returned by Qfi.Validate if the
// designated constraints aren't met.
type QfiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QfiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QfiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QfiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QfiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QfiValidationError) ErrorName() string { return "QfiValidationError" }

// Error satisfies the builtin error interface
func (e QfiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQfi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QfiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QfiValidationError{}

// Validate checks the field values on Arp with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Arp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Arp with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ArpMultiError, or nil if none found.
func (m *Arp) ValidateAll() error {
	return m.validate(true)
}

func (m *Arp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 15 {
		err := ArpValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 15]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ArpMultiError(errors)
	}
	return nil
}

// ArpMultiError is an error wrapping multiple validation errors returned by
// Arp.ValidateAll() if the designated constraints aren't met.
type ArpMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArpMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArpMultiError) AllErrors() []error { return m }

// ArpValidationError is the validation error returned by Arp.Validate if the
// designated constraints aren't met.
type ArpValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArpValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArpValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArpValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArpValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArpValidationError) ErrorName() string { return "ArpValidationError" }

// Error satisfies the builtin error interface
func (e ArpValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArpValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArpValidationError{}

// Validate checks the field values on GranularityPeriod with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GranularityPeriod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GranularityPeriod with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GranularityPeriodMultiError, or nil if none found.
func (m *GranularityPeriod) ValidateAll() error {
	return m.validate(true)
}

func (m *GranularityPeriod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return GranularityPeriodMultiError(errors)
	}
	return nil
}

// GranularityPeriodMultiError is an error wrapping multiple validation errors
// returned by GranularityPeriod.ValidateAll() if the designated constraints
// aren't met.
type GranularityPeriodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GranularityPeriodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GranularityPeriodMultiError) AllErrors() []error { return m }

// GranularityPeriodValidationError is the validation error returned by
// GranularityPeriod.Validate if the designated constraints aren't met.
type GranularityPeriodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GranularityPeriodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GranularityPeriodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GranularityPeriodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GranularityPeriodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GranularityPeriodValidationError) ErrorName() string {
	return "GranularityPeriodValidationError"
}

// Error satisfies the builtin error interface
func (e GranularityPeriodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGranularityPeriod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GranularityPeriodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GranularityPeriodValidationError{}

// Validate checks the field values on MeasurementType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeMultiError, or nil if none found.
func (m *MeasurementType) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.MeasurementType.(type) {

	case *MeasurementType_MeasName:

		if all {
			switch v := interface{}(m.GetMeasName()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementTypeValidationError{
						field:  "MeasName",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementTypeValidationError{
						field:  "MeasName",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasName()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementTypeValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MeasurementType_MeasId:

		if all {
			switch v := interface{}(m.GetMeasId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementTypeValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementTypeValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementTypeValidationError{
					field:  "MeasId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementTypeMultiError(errors)
	}
	return nil
}

// MeasurementTypeMultiError is an error wrapping multiple validation errors
// returned by MeasurementType.ValidateAll() if the designated constraints
// aren't met.
type MeasurementTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeMultiError) AllErrors() []error { return m }

// MeasurementTypeValidationError is the validation error returned by
// MeasurementType.Validate if the designated constraints aren't met.
type MeasurementTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeValidationError) ErrorName() string { return "MeasurementTypeValidationError" }

// Error satisfies the builtin error interface
func (e MeasurementTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeValidationError{}

// Validate checks the field values on MeasurementTypeId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementTypeId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementTypeId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeIdMultiError, or nil if none found.
func (m *MeasurementTypeId) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementTypeId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 65536 {
		err := MeasurementTypeIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 65536]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementTypeIdMultiError(errors)
	}
	return nil
}

// MeasurementTypeIdMultiError is an error wrapping multiple validation errors
// returned by MeasurementTypeId.ValidateAll() if the designated constraints
// aren't met.
type MeasurementTypeIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeIdMultiError) AllErrors() []error { return m }

// MeasurementTypeIdValidationError is the validation error returned by
// MeasurementTypeId.Validate if the designated constraints aren't met.
type MeasurementTypeIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeIdValidationError) ErrorName() string {
	return "MeasurementTypeIdValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementTypeIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementTypeId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeIdValidationError{}

// Validate checks the field values on MeasurementLabel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementLabel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementLabel with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementLabelMultiError, or nil if none found.
func (m *MeasurementLabel) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementLabel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlmnId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlmnId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "PlmnId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSliceId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "SliceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "SliceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSliceId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "SliceId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFiveQi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "FiveQi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "FiveQi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFiveQi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "FiveQi",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQFi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "QFi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "QFi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQFi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "QFi",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQCi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "QCi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "QCi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQCi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "QCi",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQCimax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "QCimax",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "QCimax",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQCimax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "QCimax",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQCimin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "QCimin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "QCimin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQCimin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "QCimin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetARpmax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "ARpmax",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "ARpmax",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetARpmax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "ARpmax",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetARpmin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "ARpmin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementLabelValidationError{
					field:  "ARpmin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetARpmin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementLabelValidationError{
				field:  "ARpmin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetBitrateRange(); val < 1 || val > 65536 {
		err := MeasurementLabelValidationError{
			field:  "BitrateRange",
			reason: "value must be inside range [1, 65536]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLayerMuMimo(); val < 1 || val > 65536 {
		err := MeasurementLabelValidationError{
			field:  "LayerMuMimo",
			reason: "value must be inside range [1, 65536]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SUm

	if val := m.GetDistBinX(); val < 1 || val > 65536 {
		err := MeasurementLabelValidationError{
			field:  "DistBinX",
			reason: "value must be inside range [1, 65536]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetDistBinY(); val < 1 || val > 65536 {
		err := MeasurementLabelValidationError{
			field:  "DistBinY",
			reason: "value must be inside range [1, 65536]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetDistBinZ(); val < 1 || val > 65536 {
		err := MeasurementLabelValidationError{
			field:  "DistBinZ",
			reason: "value must be inside range [1, 65536]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PreLabelOverride

	// no validation rules for StartEndInd

	if len(errors) > 0 {
		return MeasurementLabelMultiError(errors)
	}
	return nil
}

// MeasurementLabelMultiError is an error wrapping multiple validation errors
// returned by MeasurementLabel.ValidateAll() if the designated constraints
// aren't met.
type MeasurementLabelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementLabelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementLabelMultiError) AllErrors() []error { return m }

// MeasurementLabelValidationError is the validation error returned by
// MeasurementLabel.Validate if the designated constraints aren't met.
type MeasurementLabelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementLabelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementLabelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementLabelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementLabelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementLabelValidationError) ErrorName() string { return "MeasurementLabelValidationError" }

// Error satisfies the builtin error interface
func (e MeasurementLabelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementLabel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementLabelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementLabelValidationError{}

// Validate checks the field values on SubscriptionId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubscriptionId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubscriptionIdMultiError,
// or nil if none found.
func (m *SubscriptionId) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967296 {
		err := SubscriptionIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967296]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SubscriptionIdMultiError(errors)
	}
	return nil
}

// SubscriptionIdMultiError is an error wrapping multiple validation errors
// returned by SubscriptionId.ValidateAll() if the designated constraints
// aren't met.
type SubscriptionIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionIdMultiError) AllErrors() []error { return m }

// SubscriptionIdValidationError is the validation error returned by
// SubscriptionId.Validate if the designated constraints aren't met.
type SubscriptionIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionIdValidationError) ErrorName() string { return "SubscriptionIdValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionIdValidationError{}

// Validate checks the field values on TestCondInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestCondInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCondInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestCondInfoMultiError, or
// nil if none found.
func (m *TestCondInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCondInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestCondInfoValidationError{
					field:  "TestType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestCondInfoValidationError{
					field:  "TestType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestCondInfoValidationError{
				field:  "TestType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TestExpr

	if all {
		switch v := interface{}(m.GetTestValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestCondInfoValidationError{
					field:  "TestValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestCondInfoValidationError{
					field:  "TestValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestCondInfoValidationError{
				field:  "TestValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TestCondInfoMultiError(errors)
	}
	return nil
}

// TestCondInfoMultiError is an error wrapping multiple validation errors
// returned by TestCondInfo.ValidateAll() if the designated constraints aren't met.
type TestCondInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCondInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCondInfoMultiError) AllErrors() []error { return m }

// TestCondInfoValidationError is the validation error returned by
// TestCondInfo.Validate if the designated constraints aren't met.
type TestCondInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCondInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCondInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCondInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCondInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCondInfoValidationError) ErrorName() string { return "TestCondInfoValidationError" }

// Error satisfies the builtin error interface
func (e TestCondInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCondInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCondInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCondInfoValidationError{}

// Validate checks the field values on TestCondType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestCondType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCondType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestCondTypeMultiError, or
// nil if none found.
func (m *TestCondType) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCondType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.TestCondType.(type) {

	case *TestCondType_GBr:
		// no validation rules for GBr

	case *TestCondType_AMbr:
		// no validation rules for AMbr

	case *TestCondType_IsStat:
		// no validation rules for IsStat

	case *TestCondType_IsCatM:
		// no validation rules for IsCatM

	case *TestCondType_RSrp:
		// no validation rules for RSrp

	case *TestCondType_RSrq:
		// no validation rules for RSrq

	}

	if len(errors) > 0 {
		return TestCondTypeMultiError(errors)
	}
	return nil
}

// TestCondTypeMultiError is an error wrapping multiple validation errors
// returned by TestCondType.ValidateAll() if the designated constraints aren't met.
type TestCondTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCondTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCondTypeMultiError) AllErrors() []error { return m }

// TestCondTypeValidationError is the validation error returned by
// TestCondType.Validate if the designated constraints aren't met.
type TestCondTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCondTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCondTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCondTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCondTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCondTypeValidationError) ErrorName() string { return "TestCondTypeValidationError" }

// Error satisfies the builtin error interface
func (e TestCondTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCondType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCondTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCondTypeValidationError{}

// Validate checks the field values on TestCondValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestCondValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCondValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestCondValueMultiError, or
// nil if none found.
func (m *TestCondValue) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCondValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.TestCondValue.(type) {

	case *TestCondValue_ValueInt:
		// no validation rules for ValueInt

	case *TestCondValue_ValueEnum:
		// no validation rules for ValueEnum

	case *TestCondValue_ValueBool:
		// no validation rules for ValueBool

	case *TestCondValue_ValueBitS:

		if all {
			switch v := interface{}(m.GetValueBitS()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCondValueValidationError{
						field:  "ValueBitS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCondValueValidationError{
						field:  "ValueBitS",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetValueBitS()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCondValueValidationError{
					field:  "ValueBitS",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TestCondValue_ValueOctS:
		// no validation rules for ValueOctS

	case *TestCondValue_ValuePrtS:
		// no validation rules for ValuePrtS

	}

	if len(errors) > 0 {
		return TestCondValueMultiError(errors)
	}
	return nil
}

// TestCondValueMultiError is an error wrapping multiple validation errors
// returned by TestCondValue.ValidateAll() if the designated constraints
// aren't met.
type TestCondValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCondValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCondValueMultiError) AllErrors() []error { return m }

// TestCondValueValidationError is the validation error returned by
// TestCondValue.Validate if the designated constraints aren't met.
type TestCondValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCondValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCondValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCondValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCondValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCondValueValidationError) ErrorName() string { return "TestCondValueValidationError" }

// Error satisfies the builtin error interface
func (e TestCondValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCondValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCondValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCondValueValidationError{}

// Validate checks the field values on GlobalKpmnodeId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GlobalKpmnodeId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalKpmnodeId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalKpmnodeIdMultiError, or nil if none found.
func (m *GlobalKpmnodeId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalKpmnodeId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.GlobalKpmnodeId.(type) {

	case *GlobalKpmnodeId_GNb:

		if all {
			switch v := interface{}(m.GetGNb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalKpmnodeIdValidationError{
						field:  "GNb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalKpmnodeIdValidationError{
						field:  "GNb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalKpmnodeIdValidationError{
					field:  "GNb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GlobalKpmnodeId_EnGNb:

		if all {
			switch v := interface{}(m.GetEnGNb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalKpmnodeIdValidationError{
						field:  "EnGNb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalKpmnodeIdValidationError{
						field:  "EnGNb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnGNb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalKpmnodeIdValidationError{
					field:  "EnGNb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GlobalKpmnodeId_NgENb:

		if all {
			switch v := interface{}(m.GetNgENb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalKpmnodeIdValidationError{
						field:  "NgENb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalKpmnodeIdValidationError{
						field:  "NgENb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNgENb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalKpmnodeIdValidationError{
					field:  "NgENb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GlobalKpmnodeId_ENb:

		if all {
			switch v := interface{}(m.GetENb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalKpmnodeIdValidationError{
						field:  "ENb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalKpmnodeIdValidationError{
						field:  "ENb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetENb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalKpmnodeIdValidationError{
					field:  "ENb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GlobalKpmnodeIdMultiError(errors)
	}
	return nil
}

// GlobalKpmnodeIdMultiError is an error wrapping multiple validation errors
// returned by GlobalKpmnodeId.ValidateAll() if the designated constraints
// aren't met.
type GlobalKpmnodeIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalKpmnodeIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalKpmnodeIdMultiError) AllErrors() []error { return m }

// GlobalKpmnodeIdValidationError is the validation error returned by
// GlobalKpmnodeId.Validate if the designated constraints aren't met.
type GlobalKpmnodeIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalKpmnodeIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalKpmnodeIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalKpmnodeIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalKpmnodeIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalKpmnodeIdValidationError) ErrorName() string { return "GlobalKpmnodeIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalKpmnodeIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalKpmnodeId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalKpmnodeIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalKpmnodeIdValidationError{}

// Validate checks the field values on GlobalKpmnodeGnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GlobalKpmnodeGnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalKpmnodeGnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalKpmnodeGnbIdMultiError, or nil if none found.
func (m *GlobalKpmnodeGnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalKpmnodeGnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGlobalGNbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeGnbIdValidationError{
					field:  "GlobalGNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeGnbIdValidationError{
					field:  "GlobalGNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalGNbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeGnbIdValidationError{
				field:  "GlobalGNbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGNbCuUpId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeGnbIdValidationError{
					field:  "GNbCuUpId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeGnbIdValidationError{
					field:  "GNbCuUpId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGNbCuUpId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeGnbIdValidationError{
				field:  "GNbCuUpId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGNbDuId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeGnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeGnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGNbDuId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeGnbIdValidationError{
				field:  "GNbDuId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalKpmnodeGnbIdMultiError(errors)
	}
	return nil
}

// GlobalKpmnodeGnbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalKpmnodeGnbId.ValidateAll() if the designated constraints
// aren't met.
type GlobalKpmnodeGnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalKpmnodeGnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalKpmnodeGnbIdMultiError) AllErrors() []error { return m }

// GlobalKpmnodeGnbIdValidationError is the validation error returned by
// GlobalKpmnodeGnbId.Validate if the designated constraints aren't met.
type GlobalKpmnodeGnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalKpmnodeGnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalKpmnodeGnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalKpmnodeGnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalKpmnodeGnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalKpmnodeGnbIdValidationError) ErrorName() string {
	return "GlobalKpmnodeGnbIdValidationError"
}

// Error satisfies the builtin error interface
func (e GlobalKpmnodeGnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalKpmnodeGnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalKpmnodeGnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalKpmnodeGnbIdValidationError{}

// Validate checks the field values on GlobalgNbId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GlobalgNbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalgNbId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GlobalgNbIdMultiError, or
// nil if none found.
func (m *GlobalgNbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalgNbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlmnId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalgNbIdValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalgNbIdValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlmnId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalgNbIdValidationError{
				field:  "PlmnId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGnbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalgNbIdValidationError{
					field:  "GnbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalgNbIdValidationError{
					field:  "GnbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGnbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalgNbIdValidationError{
				field:  "GnbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalgNbIdMultiError(errors)
	}
	return nil
}

// GlobalgNbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalgNbId.ValidateAll() if the designated constraints aren't met.
type GlobalgNbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalgNbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalgNbIdMultiError) AllErrors() []error { return m }

// GlobalgNbIdValidationError is the validation error returned by
// GlobalgNbId.Validate if the designated constraints aren't met.
type GlobalgNbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalgNbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalgNbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalgNbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalgNbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalgNbIdValidationError) ErrorName() string { return "GlobalgNbIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalgNbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalgNbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalgNbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalgNbIdValidationError{}

// Validate checks the field values on GnbCuUpId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GnbCuUpId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GnbCuUpId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GnbCuUpIdMultiError, or nil
// if none found.
func (m *GnbCuUpId) ValidateAll() error {
	return m.validate(true)
}

func (m *GnbCuUpId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 68719476735 {
		err := GnbCuUpIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 68719476735]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GnbCuUpIdMultiError(errors)
	}
	return nil
}

// GnbCuUpIdMultiError is an error wrapping multiple validation errors returned
// by GnbCuUpId.ValidateAll() if the designated constraints aren't met.
type GnbCuUpIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GnbCuUpIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GnbCuUpIdMultiError) AllErrors() []error { return m }

// GnbCuUpIdValidationError is the validation error returned by
// GnbCuUpId.Validate if the designated constraints aren't met.
type GnbCuUpIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GnbCuUpIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GnbCuUpIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GnbCuUpIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GnbCuUpIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GnbCuUpIdValidationError) ErrorName() string { return "GnbCuUpIdValidationError" }

// Error satisfies the builtin error interface
func (e GnbCuUpIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGnbCuUpId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GnbCuUpIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GnbCuUpIdValidationError{}

// Validate checks the field values on GnbDuId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GnbDuId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GnbDuId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GnbDuIdMultiError, or nil if none found.
func (m *GnbDuId) ValidateAll() error {
	return m.validate(true)
}

func (m *GnbDuId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 68719476735 {
		err := GnbDuIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 68719476735]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GnbDuIdMultiError(errors)
	}
	return nil
}

// GnbDuIdMultiError is an error wrapping multiple validation errors returned
// by GnbDuId.ValidateAll() if the designated constraints aren't met.
type GnbDuIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GnbDuIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GnbDuIdMultiError) AllErrors() []error { return m }

// GnbDuIdValidationError is the validation error returned by GnbDuId.Validate
// if the designated constraints aren't met.
type GnbDuIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GnbDuIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GnbDuIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GnbDuIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GnbDuIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GnbDuIdValidationError) ErrorName() string { return "GnbDuIdValidationError" }

// Error satisfies the builtin error interface
func (e GnbDuIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGnbDuId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GnbDuIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GnbDuIdValidationError{}

// Validate checks the field values on GnbIdChoice with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GnbIdChoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GnbIdChoice with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GnbIdChoiceMultiError, or
// nil if none found.
func (m *GnbIdChoice) ValidateAll() error {
	return m.validate(true)
}

func (m *GnbIdChoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.GnbIdChoice.(type) {

	case *GnbIdChoice_GnbId:

		if all {
			switch v := interface{}(m.GetGnbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GnbIdChoiceValidationError{
						field:  "GnbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GnbIdChoiceValidationError{
						field:  "GnbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGnbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GnbIdChoiceValidationError{
					field:  "GnbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GnbIdChoiceMultiError(errors)
	}
	return nil
}

// GnbIdChoiceMultiError is an error wrapping multiple validation errors
// returned by GnbIdChoice.ValidateAll() if the designated constraints aren't met.
type GnbIdChoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GnbIdChoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GnbIdChoiceMultiError) AllErrors() []error { return m }

// GnbIdChoiceValidationError is the validation error returned by
// GnbIdChoice.Validate if the designated constraints aren't met.
type GnbIdChoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GnbIdChoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GnbIdChoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GnbIdChoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GnbIdChoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GnbIdChoiceValidationError) ErrorName() string { return "GnbIdChoiceValidationError" }

// Error satisfies the builtin error interface
func (e GnbIdChoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGnbIdChoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GnbIdChoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GnbIdChoiceValidationError{}

// Validate checks the field values on GlobalKpmnodeEnGnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GlobalKpmnodeEnGnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalKpmnodeEnGnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalKpmnodeEnGnbIdMultiError, or nil if none found.
func (m *GlobalKpmnodeEnGnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalKpmnodeEnGnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGlobalGNbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeEnGnbIdValidationError{
					field:  "GlobalGNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeEnGnbIdValidationError{
					field:  "GlobalGNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalGNbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeEnGnbIdValidationError{
				field:  "GlobalGNbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGNbCuUpId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeEnGnbIdValidationError{
					field:  "GNbCuUpId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeEnGnbIdValidationError{
					field:  "GNbCuUpId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGNbCuUpId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeEnGnbIdValidationError{
				field:  "GNbCuUpId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGNbDuId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeEnGnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeEnGnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGNbDuId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeEnGnbIdValidationError{
				field:  "GNbDuId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalKpmnodeEnGnbIdMultiError(errors)
	}
	return nil
}

// GlobalKpmnodeEnGnbIdMultiError is an error wrapping multiple validation
// errors returned by GlobalKpmnodeEnGnbId.ValidateAll() if the designated
// constraints aren't met.
type GlobalKpmnodeEnGnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalKpmnodeEnGnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalKpmnodeEnGnbIdMultiError) AllErrors() []error { return m }

// GlobalKpmnodeEnGnbIdValidationError is the validation error returned by
// GlobalKpmnodeEnGnbId.Validate if the designated constraints aren't met.
type GlobalKpmnodeEnGnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalKpmnodeEnGnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalKpmnodeEnGnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalKpmnodeEnGnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalKpmnodeEnGnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalKpmnodeEnGnbIdValidationError) ErrorName() string {
	return "GlobalKpmnodeEnGnbIdValidationError"
}

// Error satisfies the builtin error interface
func (e GlobalKpmnodeEnGnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalKpmnodeEnGnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalKpmnodeEnGnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalKpmnodeEnGnbIdValidationError{}

// Validate checks the field values on GlobalenGnbId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GlobalenGnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalenGnbId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GlobalenGnbIdMultiError, or
// nil if none found.
func (m *GlobalenGnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalenGnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPLmnIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalenGnbIdValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalenGnbIdValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPLmnIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalenGnbIdValidationError{
				field:  "PLmnIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGNbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalenGnbIdValidationError{
					field:  "GNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalenGnbIdValidationError{
					field:  "GNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGNbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalenGnbIdValidationError{
				field:  "GNbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalenGnbIdMultiError(errors)
	}
	return nil
}

// GlobalenGnbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalenGnbId.ValidateAll() if the designated constraints
// aren't met.
type GlobalenGnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalenGnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalenGnbIdMultiError) AllErrors() []error { return m }

// GlobalenGnbIdValidationError is the validation error returned by
// GlobalenGnbId.Validate if the designated constraints aren't met.
type GlobalenGnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalenGnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalenGnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalenGnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalenGnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalenGnbIdValidationError) ErrorName() string { return "GlobalenGnbIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalenGnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalenGnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalenGnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalenGnbIdValidationError{}

// Validate checks the field values on EngnbId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EngnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EngnbId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EngnbIdMultiError, or nil if none found.
func (m *EngnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *EngnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.EngnbId.(type) {

	case *EngnbId_GNbId:

		if all {
			switch v := interface{}(m.GetGNbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EngnbIdValidationError{
						field:  "GNbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EngnbIdValidationError{
						field:  "GNbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EngnbIdValidationError{
					field:  "GNbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EngnbIdMultiError(errors)
	}
	return nil
}

// EngnbIdMultiError is an error wrapping multiple validation errors returned
// by EngnbId.ValidateAll() if the designated constraints aren't met.
type EngnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EngnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EngnbIdMultiError) AllErrors() []error { return m }

// EngnbIdValidationError is the validation error returned by EngnbId.Validate
// if the designated constraints aren't met.
type EngnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EngnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EngnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EngnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EngnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EngnbIdValidationError) ErrorName() string { return "EngnbIdValidationError" }

// Error satisfies the builtin error interface
func (e EngnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEngnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EngnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EngnbIdValidationError{}

// Validate checks the field values on GlobalKpmnodeNgEnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GlobalKpmnodeNgEnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalKpmnodeNgEnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalKpmnodeNgEnbIdMultiError, or nil if none found.
func (m *GlobalKpmnodeNgEnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalKpmnodeNgEnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGlobalNgENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeNgEnbIdValidationError{
					field:  "GlobalNgENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeNgEnbIdValidationError{
					field:  "GlobalNgENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalNgENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeNgEnbIdValidationError{
				field:  "GlobalNgENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGNbDuId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeNgEnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeNgEnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGNbDuId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeNgEnbIdValidationError{
				field:  "GNbDuId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalKpmnodeNgEnbIdMultiError(errors)
	}
	return nil
}

// GlobalKpmnodeNgEnbIdMultiError is an error wrapping multiple validation
// errors returned by GlobalKpmnodeNgEnbId.ValidateAll() if the designated
// constraints aren't met.
type GlobalKpmnodeNgEnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalKpmnodeNgEnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalKpmnodeNgEnbIdMultiError) AllErrors() []error { return m }

// GlobalKpmnodeNgEnbIdValidationError is the validation error returned by
// GlobalKpmnodeNgEnbId.Validate if the designated constraints aren't met.
type GlobalKpmnodeNgEnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalKpmnodeNgEnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalKpmnodeNgEnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalKpmnodeNgEnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalKpmnodeNgEnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalKpmnodeNgEnbIdValidationError) ErrorName() string {
	return "GlobalKpmnodeNgEnbIdValidationError"
}

// Error satisfies the builtin error interface
func (e GlobalKpmnodeNgEnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalKpmnodeNgEnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalKpmnodeNgEnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalKpmnodeNgEnbIdValidationError{}

// Validate checks the field values on GlobalngeNbId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GlobalngeNbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalngeNbId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GlobalngeNbIdMultiError, or
// nil if none found.
func (m *GlobalngeNbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalngeNbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlmnId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlmnId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalngeNbIdValidationError{
				field:  "PlmnId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "EnbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "EnbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalngeNbIdValidationError{
				field:  "EnbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetShortMacroENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "ShortMacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "ShortMacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShortMacroENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalngeNbIdValidationError{
				field:  "ShortMacroENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLongMacroENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "LongMacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "LongMacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLongMacroENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalngeNbIdValidationError{
				field:  "LongMacroENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalngeNbIdMultiError(errors)
	}
	return nil
}

// GlobalngeNbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalngeNbId.ValidateAll() if the designated constraints
// aren't met.
type GlobalngeNbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalngeNbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalngeNbIdMultiError) AllErrors() []error { return m }

// GlobalngeNbIdValidationError is the validation error returned by
// GlobalngeNbId.Validate if the designated constraints aren't met.
type GlobalngeNbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalngeNbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalngeNbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalngeNbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalngeNbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalngeNbIdValidationError) ErrorName() string { return "GlobalngeNbIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalngeNbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalngeNbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalngeNbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalngeNbIdValidationError{}

// Validate checks the field values on EnbIdChoice with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnbIdChoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnbIdChoice with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnbIdChoiceMultiError, or
// nil if none found.
func (m *EnbIdChoice) ValidateAll() error {
	return m.validate(true)
}

func (m *EnbIdChoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.EnbIdChoice.(type) {

	case *EnbIdChoice_EnbIdMacro:

		if all {
			switch v := interface{}(m.GetEnbIdMacro()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdMacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdMacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnbIdMacro()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdChoiceValidationError{
					field:  "EnbIdMacro",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnbIdChoice_EnbIdShortmacro:

		if all {
			switch v := interface{}(m.GetEnbIdShortmacro()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdShortmacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdShortmacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnbIdShortmacro()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdChoiceValidationError{
					field:  "EnbIdShortmacro",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnbIdChoice_EnbIdLongmacro:

		if all {
			switch v := interface{}(m.GetEnbIdLongmacro()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdLongmacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdLongmacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnbIdLongmacro()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdChoiceValidationError{
					field:  "EnbIdLongmacro",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnbIdChoiceMultiError(errors)
	}
	return nil
}

// EnbIdChoiceMultiError is an error wrapping multiple validation errors
// returned by EnbIdChoice.ValidateAll() if the designated constraints aren't met.
type EnbIdChoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnbIdChoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnbIdChoiceMultiError) AllErrors() []error { return m }

// EnbIdChoiceValidationError is the validation error returned by
// EnbIdChoice.Validate if the designated constraints aren't met.
type EnbIdChoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnbIdChoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnbIdChoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnbIdChoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnbIdChoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnbIdChoiceValidationError) ErrorName() string { return "EnbIdChoiceValidationError" }

// Error satisfies the builtin error interface
func (e EnbIdChoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnbIdChoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnbIdChoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnbIdChoiceValidationError{}

// Validate checks the field values on GlobalKpmnodeEnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GlobalKpmnodeEnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalKpmnodeEnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalKpmnodeEnbIdMultiError, or nil if none found.
func (m *GlobalKpmnodeEnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalKpmnodeEnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGlobalENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalKpmnodeEnbIdValidationError{
					field:  "GlobalENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalKpmnodeEnbIdValidationError{
					field:  "GlobalENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalKpmnodeEnbIdValidationError{
				field:  "GlobalENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalKpmnodeEnbIdMultiError(errors)
	}
	return nil
}

// GlobalKpmnodeEnbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalKpmnodeEnbId.ValidateAll() if the designated constraints
// aren't met.
type GlobalKpmnodeEnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalKpmnodeEnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalKpmnodeEnbIdMultiError) AllErrors() []error { return m }

// GlobalKpmnodeEnbIdValidationError is the validation error returned by
// GlobalKpmnodeEnbId.Validate if the designated constraints aren't met.
type GlobalKpmnodeEnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalKpmnodeEnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalKpmnodeEnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalKpmnodeEnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalKpmnodeEnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalKpmnodeEnbIdValidationError) ErrorName() string {
	return "GlobalKpmnodeEnbIdValidationError"
}

// Error satisfies the builtin error interface
func (e GlobalKpmnodeEnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalKpmnodeEnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalKpmnodeEnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalKpmnodeEnbIdValidationError{}

// Validate checks the field values on GlobalEnbId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GlobalEnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalEnbId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GlobalEnbIdMultiError, or
// nil if none found.
func (m *GlobalEnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalEnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPLmnIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalEnbIdValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalEnbIdValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPLmnIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalEnbIdValidationError{
				field:  "PLmnIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalEnbIdValidationError{
					field:  "ENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalEnbIdValidationError{
					field:  "ENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalEnbIdValidationError{
				field:  "ENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalEnbIdMultiError(errors)
	}
	return nil
}

// GlobalEnbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalEnbId.ValidateAll() if the designated constraints aren't met.
type GlobalEnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalEnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalEnbIdMultiError) AllErrors() []error { return m }

// GlobalEnbIdValidationError is the validation error returned by
// GlobalEnbId.Validate if the designated constraints aren't met.
type GlobalEnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalEnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalEnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalEnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalEnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalEnbIdValidationError) ErrorName() string { return "GlobalEnbIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalEnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalEnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalEnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalEnbIdValidationError{}

// Validate checks the field values on EnbId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnbId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EnbIdMultiError, or nil if none found.
func (m *EnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *EnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.EnbId.(type) {

	case *EnbId_MacroENbId:

		if all {
			switch v := interface{}(m.GetMacroENbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdValidationError{
						field:  "MacroENbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdValidationError{
						field:  "MacroENbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMacroENbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdValidationError{
					field:  "MacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnbId_HomeENbId:

		if all {
			switch v := interface{}(m.GetHomeENbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdValidationError{
						field:  "HomeENbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdValidationError{
						field:  "HomeENbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHomeENbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdValidationError{
					field:  "HomeENbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnbIdMultiError(errors)
	}
	return nil
}

// EnbIdMultiError is an error wrapping multiple validation errors returned by
// EnbId.ValidateAll() if the designated constraints aren't met.
type EnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnbIdMultiError) AllErrors() []error { return m }

// EnbIdValidationError is the validation error returned by EnbId.Validate if
// the designated constraints aren't met.
type EnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnbIdValidationError) ErrorName() string { return "EnbIdValidationError" }

// Error satisfies the builtin error interface
func (e EnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnbIdValidationError{}

// Validate checks the field values on RanfunctionName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RanfunctionName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RanfunctionName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RanfunctionNameMultiError, or nil if none found.
func (m *RanfunctionName) ValidateAll() error {
	return m.validate(true)
}

func (m *RanfunctionName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RanFunctionShortName

	// no validation rules for RanFunctionE2SmOid

	// no validation rules for RanFunctionDescription

	// no validation rules for RanFunctionInstance

	if len(errors) > 0 {
		return RanfunctionNameMultiError(errors)
	}
	return nil
}

// RanfunctionNameMultiError is an error wrapping multiple validation errors
// returned by RanfunctionName.ValidateAll() if the designated constraints
// aren't met.
type RanfunctionNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RanfunctionNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RanfunctionNameMultiError) AllErrors() []error { return m }

// RanfunctionNameValidationError is the validation error returned by
// RanfunctionName.Validate if the designated constraints aren't met.
type RanfunctionNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RanfunctionNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RanfunctionNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RanfunctionNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RanfunctionNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RanfunctionNameValidationError) ErrorName() string { return "RanfunctionNameValidationError" }

// Error satisfies the builtin error interface
func (e RanfunctionNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRanfunctionName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RanfunctionNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RanfunctionNameValidationError{}

// Validate checks the field values on RicStyleType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicStyleType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicStyleType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicStyleTypeMultiError, or
// nil if none found.
func (m *RicStyleType) ValidateAll() error {
	return m.validate(true)
}

func (m *RicStyleType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return RicStyleTypeMultiError(errors)
	}
	return nil
}

// RicStyleTypeMultiError is an error wrapping multiple validation errors
// returned by RicStyleType.ValidateAll() if the designated constraints aren't met.
type RicStyleTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicStyleTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicStyleTypeMultiError) AllErrors() []error { return m }

// RicStyleTypeValidationError is the validation error returned by
// RicStyleType.Validate if the designated constraints aren't met.
type RicStyleTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicStyleTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicStyleTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicStyleTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicStyleTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicStyleTypeValidationError) ErrorName() string { return "RicStyleTypeValidationError" }

// Error satisfies the builtin error interface
func (e RicStyleTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicStyleType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicStyleTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicStyleTypeValidationError{}

// Validate checks the field values on RicFormatType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicFormatType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicFormatType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicFormatTypeMultiError, or
// nil if none found.
func (m *RicFormatType) ValidateAll() error {
	return m.validate(true)
}

func (m *RicFormatType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return RicFormatTypeMultiError(errors)
	}
	return nil
}

// RicFormatTypeMultiError is an error wrapping multiple validation errors
// returned by RicFormatType.ValidateAll() if the designated constraints
// aren't met.
type RicFormatTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicFormatTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicFormatTypeMultiError) AllErrors() []error { return m }

// RicFormatTypeValidationError is the validation error returned by
// RicFormatType.Validate if the designated constraints aren't met.
type RicFormatTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicFormatTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicFormatTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicFormatTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicFormatTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicFormatTypeValidationError) ErrorName() string { return "RicFormatTypeValidationError" }

// Error satisfies the builtin error interface
func (e RicFormatTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicFormatType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicFormatTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicFormatTypeValidationError{}

// Validate checks the field values on MaxnoofKpmnodes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofKpmnodes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofKpmnodes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofKpmnodesMultiError, or nil if none found.
func (m *MaxnoofKpmnodes) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofKpmnodes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 1024 {
		err := MaxnoofKpmnodesValidationError{
			field:  "Value",
			reason: "value must equal 1024",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofKpmnodesMultiError(errors)
	}
	return nil
}

// MaxnoofKpmnodesMultiError is an error wrapping multiple validation errors
// returned by MaxnoofKpmnodes.ValidateAll() if the designated constraints
// aren't met.
type MaxnoofKpmnodesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofKpmnodesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofKpmnodesMultiError) AllErrors() []error { return m }

// MaxnoofKpmnodesValidationError is the validation error returned by
// MaxnoofKpmnodes.Validate if the designated constraints aren't met.
type MaxnoofKpmnodesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofKpmnodesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofKpmnodesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofKpmnodesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofKpmnodesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofKpmnodesValidationError) ErrorName() string { return "MaxnoofKpmnodesValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofKpmnodesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofKpmnodes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofKpmnodesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofKpmnodesValidationError{}

// Validate checks the field values on MaxnoofCells with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxnoofCells) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofCells with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MaxnoofCellsMultiError, or
// nil if none found.
func (m *MaxnoofCells) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofCells) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 16384 {
		err := MaxnoofCellsValidationError{
			field:  "Value",
			reason: "value must equal 16384",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofCellsMultiError(errors)
	}
	return nil
}

// MaxnoofCellsMultiError is an error wrapping multiple validation errors
// returned by MaxnoofCells.ValidateAll() if the designated constraints aren't met.
type MaxnoofCellsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofCellsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofCellsMultiError) AllErrors() []error { return m }

// MaxnoofCellsValidationError is the validation error returned by
// MaxnoofCells.Validate if the designated constraints aren't met.
type MaxnoofCellsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofCellsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofCellsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofCellsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofCellsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofCellsValidationError) ErrorName() string { return "MaxnoofCellsValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofCellsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofCells.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofCellsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofCellsValidationError{}

// Validate checks the field values on MaxnoofRicstyles with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofRicstyles) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofRicstyles with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofRicstylesMultiError, or nil if none found.
func (m *MaxnoofRicstyles) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofRicstyles) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 63 {
		err := MaxnoofRicstylesValidationError{
			field:  "Value",
			reason: "value must equal 63",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofRicstylesMultiError(errors)
	}
	return nil
}

// MaxnoofRicstylesMultiError is an error wrapping multiple validation errors
// returned by MaxnoofRicstyles.ValidateAll() if the designated constraints
// aren't met.
type MaxnoofRicstylesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofRicstylesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofRicstylesMultiError) AllErrors() []error { return m }

// MaxnoofRicstylesValidationError is the validation error returned by
// MaxnoofRicstyles.Validate if the designated constraints aren't met.
type MaxnoofRicstylesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofRicstylesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofRicstylesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofRicstylesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofRicstylesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofRicstylesValidationError) ErrorName() string { return "MaxnoofRicstylesValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofRicstylesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofRicstyles.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofRicstylesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofRicstylesValidationError{}

// Validate checks the field values on MaxnoofMeasurementInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofMeasurementInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofMeasurementInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofMeasurementInfoMultiError, or nil if none found.
func (m *MaxnoofMeasurementInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofMeasurementInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65536 {
		err := MaxnoofMeasurementInfoValidationError{
			field:  "Value",
			reason: "value must equal 65536",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofMeasurementInfoMultiError(errors)
	}
	return nil
}

// MaxnoofMeasurementInfoMultiError is an error wrapping multiple validation
// errors returned by MaxnoofMeasurementInfo.ValidateAll() if the designated
// constraints aren't met.
type MaxnoofMeasurementInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofMeasurementInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofMeasurementInfoMultiError) AllErrors() []error { return m }

// MaxnoofMeasurementInfoValidationError is the validation error returned by
// MaxnoofMeasurementInfo.Validate if the designated constraints aren't met.
type MaxnoofMeasurementInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofMeasurementInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofMeasurementInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofMeasurementInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofMeasurementInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofMeasurementInfoValidationError) ErrorName() string {
	return "MaxnoofMeasurementInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MaxnoofMeasurementInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofMeasurementInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofMeasurementInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofMeasurementInfoValidationError{}

// Validate checks the field values on MaxnoofLabelInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofLabelInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofLabelInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofLabelInfoMultiError, or nil if none found.
func (m *MaxnoofLabelInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofLabelInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 2147483647 {
		err := MaxnoofLabelInfoValidationError{
			field:  "Value",
			reason: "value must equal 2147483647",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofLabelInfoMultiError(errors)
	}
	return nil
}

// MaxnoofLabelInfoMultiError is an error wrapping multiple validation errors
// returned by MaxnoofLabelInfo.ValidateAll() if the designated constraints
// aren't met.
type MaxnoofLabelInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofLabelInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofLabelInfoMultiError) AllErrors() []error { return m }

// MaxnoofLabelInfoValidationError is the validation error returned by
// MaxnoofLabelInfo.Validate if the designated constraints aren't met.
type MaxnoofLabelInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofLabelInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofLabelInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofLabelInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofLabelInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofLabelInfoValidationError) ErrorName() string { return "MaxnoofLabelInfoValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofLabelInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofLabelInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofLabelInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofLabelInfoValidationError{}

// Validate checks the field values on MaxnoofMeasurementRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofMeasurementRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofMeasurementRecord with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofMeasurementRecordMultiError, or nil if none found.
func (m *MaxnoofMeasurementRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofMeasurementRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65536 {
		err := MaxnoofMeasurementRecordValidationError{
			field:  "Value",
			reason: "value must equal 65536",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofMeasurementRecordMultiError(errors)
	}
	return nil
}

// MaxnoofMeasurementRecordMultiError is an error wrapping multiple validation
// errors returned by MaxnoofMeasurementRecord.ValidateAll() if the designated
// constraints aren't met.
type MaxnoofMeasurementRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofMeasurementRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofMeasurementRecordMultiError) AllErrors() []error { return m }

// MaxnoofMeasurementRecordValidationError is the validation error returned by
// MaxnoofMeasurementRecord.Validate if the designated constraints aren't met.
type MaxnoofMeasurementRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofMeasurementRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofMeasurementRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofMeasurementRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofMeasurementRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofMeasurementRecordValidationError) ErrorName() string {
	return "MaxnoofMeasurementRecordValidationError"
}

// Error satisfies the builtin error interface
func (e MaxnoofMeasurementRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofMeasurementRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofMeasurementRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofMeasurementRecordValidationError{}

// Validate checks the field values on MaxnoofMeasurementValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofMeasurementValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofMeasurementValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofMeasurementValueMultiError, or nil if none found.
func (m *MaxnoofMeasurementValue) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofMeasurementValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 2147483647 {
		err := MaxnoofMeasurementValueValidationError{
			field:  "Value",
			reason: "value must equal 2147483647",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofMeasurementValueMultiError(errors)
	}
	return nil
}

// MaxnoofMeasurementValueMultiError is an error wrapping multiple validation
// errors returned by MaxnoofMeasurementValue.ValidateAll() if the designated
// constraints aren't met.
type MaxnoofMeasurementValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofMeasurementValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofMeasurementValueMultiError) AllErrors() []error { return m }

// MaxnoofMeasurementValueValidationError is the validation error returned by
// MaxnoofMeasurementValue.Validate if the designated constraints aren't met.
type MaxnoofMeasurementValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofMeasurementValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofMeasurementValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofMeasurementValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofMeasurementValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofMeasurementValueValidationError) ErrorName() string {
	return "MaxnoofMeasurementValueValidationError"
}

// Error satisfies the builtin error interface
func (e MaxnoofMeasurementValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofMeasurementValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofMeasurementValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofMeasurementValueValidationError{}

// Validate checks the field values on MaxnoofConditionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofConditionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofConditionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofConditionInfoMultiError, or nil if none found.
func (m *MaxnoofConditionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofConditionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 32768 {
		err := MaxnoofConditionInfoValidationError{
			field:  "Value",
			reason: "value must equal 32768",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofConditionInfoMultiError(errors)
	}
	return nil
}

// MaxnoofConditionInfoMultiError is an error wrapping multiple validation
// errors returned by MaxnoofConditionInfo.ValidateAll() if the designated
// constraints aren't met.
type MaxnoofConditionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofConditionInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofConditionInfoMultiError) AllErrors() []error { return m }

// MaxnoofConditionInfoValidationError is the validation error returned by
// MaxnoofConditionInfo.Validate if the designated constraints aren't met.
type MaxnoofConditionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofConditionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofConditionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofConditionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofConditionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofConditionInfoValidationError) ErrorName() string {
	return "MaxnoofConditionInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MaxnoofConditionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofConditionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofConditionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofConditionInfoValidationError{}

// Validate checks the field values on MaxnoofUeid with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxnoofUeid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofUeid with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MaxnoofUeidMultiError, or
// nil if none found.
func (m *MaxnoofUeid) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofUeid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65535 {
		err := MaxnoofUeidValidationError{
			field:  "Value",
			reason: "value must equal 65535",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofUeidMultiError(errors)
	}
	return nil
}

// MaxnoofUeidMultiError is an error wrapping multiple validation errors
// returned by MaxnoofUeid.ValidateAll() if the designated constraints aren't met.
type MaxnoofUeidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofUeidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofUeidMultiError) AllErrors() []error { return m }

// MaxnoofUeidValidationError is the validation error returned by
// MaxnoofUeid.Validate if the designated constraints aren't met.
type MaxnoofUeidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofUeidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofUeidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofUeidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofUeidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofUeidValidationError) ErrorName() string { return "MaxnoofUeidValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofUeidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofUeid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofUeidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofUeidValidationError{}

// Validate checks the field values on MeasurementInfoList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoListMultiError, or nil if none found.
func (m *MeasurementInfoList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoListMultiError(errors)
	}
	return nil
}

// MeasurementInfoListMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoList.ValidateAll() if the designated
// constraints aren't met.
type MeasurementInfoListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoListMultiError) AllErrors() []error { return m }

// MeasurementInfoListValidationError is the validation error returned by
// MeasurementInfoList.Validate if the designated constraints aren't met.
type MeasurementInfoListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoListValidationError) ErrorName() string {
	return "MeasurementInfoListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoListValidationError{}

// Validate checks the field values on MeasurementInfoItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoItemMultiError, or nil if none found.
func (m *MeasurementInfoItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementInfoItemValidationError{
					field:  "MeasType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementInfoItemValidationError{
					field:  "MeasType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementInfoItemValidationError{
				field:  "MeasType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLabelInfoList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementInfoItemValidationError{
					field:  "LabelInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementInfoItemValidationError{
					field:  "LabelInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLabelInfoList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementInfoItemValidationError{
				field:  "LabelInfoList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MeasurementInfoItemMultiError(errors)
	}
	return nil
}

// MeasurementInfoItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementInfoItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoItemMultiError) AllErrors() []error { return m }

// MeasurementInfoItemValidationError is the validation error returned by
// MeasurementInfoItem.Validate if the designated constraints aren't met.
type MeasurementInfoItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoItemValidationError) ErrorName() string {
	return "MeasurementInfoItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoItemValidationError{}

// Validate checks the field values on LabelInfoList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LabelInfoList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelInfoList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LabelInfoListMultiError, or
// nil if none found.
func (m *LabelInfoList) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelInfoList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LabelInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LabelInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LabelInfoListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LabelInfoListMultiError(errors)
	}
	return nil
}

// LabelInfoListMultiError is an error wrapping multiple validation errors
// returned by LabelInfoList.ValidateAll() if the designated constraints
// aren't met.
type LabelInfoListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelInfoListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelInfoListMultiError) AllErrors() []error { return m }

// LabelInfoListValidationError is the validation error returned by
// LabelInfoList.Validate if the designated constraints aren't met.
type LabelInfoListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelInfoListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelInfoListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelInfoListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelInfoListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelInfoListValidationError) ErrorName() string { return "LabelInfoListValidationError" }

// Error satisfies the builtin error interface
func (e LabelInfoListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelInfoList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelInfoListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelInfoListValidationError{}

// Validate checks the field values on LabelInfoItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LabelInfoItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelInfoItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LabelInfoItemMultiError, or
// nil if none found.
func (m *LabelInfoItem) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelInfoItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasLabel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LabelInfoItemValidationError{
					field:  "MeasLabel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LabelInfoItemValidationError{
					field:  "MeasLabel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasLabel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LabelInfoItemValidationError{
				field:  "MeasLabel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LabelInfoItemMultiError(errors)
	}
	return nil
}

// LabelInfoItemMultiError is an error wrapping multiple validation errors
// returned by LabelInfoItem.ValidateAll() if the designated constraints
// aren't met.
type LabelInfoItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelInfoItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelInfoItemMultiError) AllErrors() []error { return m }

// LabelInfoItemValidationError is the validation error returned by
// LabelInfoItem.Validate if the designated constraints aren't met.
type LabelInfoItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelInfoItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelInfoItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelInfoItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelInfoItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelInfoItemValidationError) ErrorName() string { return "LabelInfoItemValidationError" }

// Error satisfies the builtin error interface
func (e LabelInfoItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelInfoItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelInfoItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelInfoItemValidationError{}

// Validate checks the field values on MeasurementData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementDataMultiError, or nil if none found.
func (m *MeasurementData) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementDataValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementDataValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementDataValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementDataMultiError(errors)
	}
	return nil
}

// MeasurementDataMultiError is an error wrapping multiple validation errors
// returned by MeasurementData.ValidateAll() if the designated constraints
// aren't met.
type MeasurementDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementDataMultiError) AllErrors() []error { return m }

// MeasurementDataValidationError is the validation error returned by
// MeasurementData.Validate if the designated constraints aren't met.
type MeasurementDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementDataValidationError) ErrorName() string { return "MeasurementDataValidationError" }

// Error satisfies the builtin error interface
func (e MeasurementDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementDataValidationError{}

// Validate checks the field values on MeasurementDataItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementDataItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementDataItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementDataItemMultiError, or nil if none found.
func (m *MeasurementDataItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementDataItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasRecord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementDataItemValidationError{
					field:  "MeasRecord",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementDataItemValidationError{
					field:  "MeasRecord",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasRecord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementDataItemValidationError{
				field:  "MeasRecord",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IncompleteFlag

	if len(errors) > 0 {
		return MeasurementDataItemMultiError(errors)
	}
	return nil
}

// MeasurementDataItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementDataItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementDataItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementDataItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementDataItemMultiError) AllErrors() []error { return m }

// MeasurementDataItemValidationError is the validation error returned by
// MeasurementDataItem.Validate if the designated constraints aren't met.
type MeasurementDataItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementDataItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementDataItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementDataItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementDataItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementDataItemValidationError) ErrorName() string {
	return "MeasurementDataItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementDataItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementDataItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementDataItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementDataItemValidationError{}

// Validate checks the field values on MeasurementRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordMultiError, or nil if none found.
func (m *MeasurementRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementRecordValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementRecordValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementRecordValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementRecordMultiError(errors)
	}
	return nil
}

// MeasurementRecordMultiError is an error wrapping multiple validation errors
// returned by MeasurementRecord.ValidateAll() if the designated constraints
// aren't met.
type MeasurementRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordMultiError) AllErrors() []error { return m }

// MeasurementRecordValidationError is the validation error returned by
// MeasurementRecord.Validate if the designated constraints aren't met.
type MeasurementRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordValidationError) ErrorName() string {
	return "MeasurementRecordValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordValidationError{}

// Validate checks the field values on MeasurementRecordItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecordItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecordItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordItemMultiError, or nil if none found.
func (m *MeasurementRecordItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecordItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.MeasurementRecordItem.(type) {

	case *MeasurementRecordItem_Integer:
		// no validation rules for Integer

	case *MeasurementRecordItem_Real:
		// no validation rules for Real

	case *MeasurementRecordItem_NoValue:

		if val := m.GetNoValue(); val < 0 || val >= 1 {
			err := MeasurementRecordItemValidationError{
				field:  "NoValue",
				reason: "value must be inside range [0, 1)",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return MeasurementRecordItemMultiError(errors)
	}
	return nil
}

// MeasurementRecordItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementRecordItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementRecordItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordItemMultiError) AllErrors() []error { return m }

// MeasurementRecordItemValidationError is the validation error returned by
// MeasurementRecordItem.Validate if the designated constraints aren't met.
type MeasurementRecordItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordItemValidationError) ErrorName() string {
	return "MeasurementRecordItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecordItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordItemValidationError{}

// Validate checks the field values on MeasurementInfoActionList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoActionList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoActionList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoActionListMultiError, or nil if none found.
func (m *MeasurementInfoActionList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoActionList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoActionListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoActionListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoActionListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoActionListMultiError(errors)
	}
	return nil
}

// MeasurementInfoActionListMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoActionList.ValidateAll() if the
// designated constraints aren't met.
type MeasurementInfoActionListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoActionListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoActionListMultiError) AllErrors() []error { return m }

// MeasurementInfoActionListValidationError is the validation error returned by
// MeasurementInfoActionList.Validate if the designated constraints aren't met.
type MeasurementInfoActionListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoActionListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoActionListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoActionListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoActionListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoActionListValidationError) ErrorName() string {
	return "MeasurementInfoActionListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoActionListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoActionList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoActionListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoActionListValidationError{}

// Validate checks the field values on MeasurementInfoActionItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoActionItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoActionItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoActionItemMultiError, or nil if none found.
func (m *MeasurementInfoActionItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoActionItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementInfoActionItemValidationError{
				field:  "MeasName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementInfoActionItemValidationError{
				field:  "MeasId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MeasurementInfoActionItemMultiError(errors)
	}
	return nil
}

// MeasurementInfoActionItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoActionItem.ValidateAll() if the
// designated constraints aren't met.
type MeasurementInfoActionItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoActionItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoActionItemMultiError) AllErrors() []error { return m }

// MeasurementInfoActionItemValidationError is the validation error returned by
// MeasurementInfoActionItem.Validate if the designated constraints aren't met.
type MeasurementInfoActionItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoActionItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoActionItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoActionItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoActionItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoActionItemValidationError) ErrorName() string {
	return "MeasurementInfoActionItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoActionItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoActionItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoActionItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoActionItemValidationError{}

// Validate checks the field values on MeasurementCondList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementCondList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementCondList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementCondListMultiError, or nil if none found.
func (m *MeasurementCondList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementCondList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementCondListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementCondListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementCondListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementCondListMultiError(errors)
	}
	return nil
}

// MeasurementCondListMultiError is an error wrapping multiple validation
// errors returned by MeasurementCondList.ValidateAll() if the designated
// constraints aren't met.
type MeasurementCondListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementCondListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementCondListMultiError) AllErrors() []error { return m }

// MeasurementCondListValidationError is the validation error returned by
// MeasurementCondList.Validate if the designated constraints aren't met.
type MeasurementCondListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementCondListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementCondListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementCondListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementCondListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementCondListValidationError) ErrorName() string {
	return "MeasurementCondListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementCondListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementCondList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementCondListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementCondListValidationError{}

// Validate checks the field values on MeasurementCondItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementCondItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementCondItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementCondItemMultiError, or nil if none found.
func (m *MeasurementCondItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementCondItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementCondItemValidationError{
					field:  "MeasType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementCondItemValidationError{
					field:  "MeasType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementCondItemValidationError{
				field:  "MeasType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMatchingCond()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementCondItemValidationError{
					field:  "MatchingCond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementCondItemValidationError{
					field:  "MatchingCond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMatchingCond()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementCondItemValidationError{
				field:  "MatchingCond",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MeasurementCondItemMultiError(errors)
	}
	return nil
}

// MeasurementCondItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementCondItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementCondItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementCondItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementCondItemMultiError) AllErrors() []error { return m }

// MeasurementCondItemValidationError is the validation error returned by
// MeasurementCondItem.Validate if the designated constraints aren't met.
type MeasurementCondItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementCondItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementCondItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementCondItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementCondItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementCondItemValidationError) ErrorName() string {
	return "MeasurementCondItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementCondItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementCondItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementCondItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementCondItemValidationError{}

// Validate checks the field values on MeasurementCondUeidList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementCondUeidList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementCondUeidList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementCondUeidListMultiError, or nil if none found.
func (m *MeasurementCondUeidList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementCondUeidList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementCondUeidListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementCondUeidListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementCondUeidListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementCondUeidListMultiError(errors)
	}
	return nil
}

// MeasurementCondUeidListMultiError is an error wrapping multiple validation
// errors returned by MeasurementCondUeidList.ValidateAll() if the designated
// constraints aren't met.
type MeasurementCondUeidListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementCondUeidListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementCondUeidListMultiError) AllErrors() []error { return m }

// MeasurementCondUeidListValidationError is the validation error returned by
// MeasurementCondUeidList.Validate if the designated constraints aren't met.
type MeasurementCondUeidListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementCondUeidListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementCondUeidListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementCondUeidListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementCondUeidListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementCondUeidListValidationError) ErrorName() string {
	return "MeasurementCondUeidListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementCondUeidListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementCondUeidList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementCondUeidListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementCondUeidListValidationError{}

// Validate checks the field values on MeasurementCondUeidItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementCondUeidItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementCondUeidItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementCondUeidItemMultiError, or nil if none found.
func (m *MeasurementCondUeidItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementCondUeidItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementCondUeidItemValidationError{
					field:  "MeasType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementCondUeidItemValidationError{
					field:  "MeasType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementCondUeidItemValidationError{
				field:  "MeasType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMatchingCond()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementCondUeidItemValidationError{
					field:  "MatchingCond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementCondUeidItemValidationError{
					field:  "MatchingCond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMatchingCond()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementCondUeidItemValidationError{
				field:  "MatchingCond",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMatchingUeidList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementCondUeidItemValidationError{
					field:  "MatchingUeidList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementCondUeidItemValidationError{
					field:  "MatchingUeidList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMatchingUeidList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementCondUeidItemValidationError{
				field:  "MatchingUeidList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MeasurementCondUeidItemMultiError(errors)
	}
	return nil
}

// MeasurementCondUeidItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementCondUeidItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementCondUeidItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementCondUeidItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementCondUeidItemMultiError) AllErrors() []error { return m }

// MeasurementCondUeidItemValidationError is the validation error returned by
// MeasurementCondUeidItem.Validate if the designated constraints aren't met.
type MeasurementCondUeidItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementCondUeidItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementCondUeidItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementCondUeidItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementCondUeidItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementCondUeidItemValidationError) ErrorName() string {
	return "MeasurementCondUeidItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementCondUeidItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementCondUeidItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementCondUeidItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementCondUeidItemValidationError{}

// Validate checks the field values on MatchingCondList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MatchingCondList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchingCondList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MatchingCondListMultiError, or nil if none found.
func (m *MatchingCondList) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchingCondList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchingCondListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchingCondListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchingCondListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MatchingCondListMultiError(errors)
	}
	return nil
}

// MatchingCondListMultiError is an error wrapping multiple validation errors
// returned by MatchingCondList.ValidateAll() if the designated constraints
// aren't met.
type MatchingCondListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchingCondListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchingCondListMultiError) AllErrors() []error { return m }

// MatchingCondListValidationError is the validation error returned by
// MatchingCondList.Validate if the designated constraints aren't met.
type MatchingCondListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchingCondListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchingCondListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchingCondListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchingCondListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchingCondListValidationError) ErrorName() string { return "MatchingCondListValidationError" }

// Error satisfies the builtin error interface
func (e MatchingCondListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchingCondList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchingCondListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchingCondListValidationError{}

// Validate checks the field values on MatchingCondItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MatchingCondItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchingCondItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MatchingCondItemMultiError, or nil if none found.
func (m *MatchingCondItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchingCondItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.MatchingCondItem.(type) {

	case *MatchingCondItem_MeasLabel:

		if all {
			switch v := interface{}(m.GetMeasLabel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchingCondItemValidationError{
						field:  "MeasLabel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchingCondItemValidationError{
						field:  "MeasLabel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasLabel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchingCondItemValidationError{
					field:  "MeasLabel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MatchingCondItem_TestCondInfo:

		if all {
			switch v := interface{}(m.GetTestCondInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchingCondItemValidationError{
						field:  "TestCondInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchingCondItemValidationError{
						field:  "TestCondInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTestCondInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchingCondItemValidationError{
					field:  "TestCondInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MatchingCondItemMultiError(errors)
	}
	return nil
}

// MatchingCondItemMultiError is an error wrapping multiple validation errors
// returned by MatchingCondItem.ValidateAll() if the designated constraints
// aren't met.
type MatchingCondItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchingCondItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchingCondItemMultiError) AllErrors() []error { return m }

// MatchingCondItemValidationError is the validation error returned by
// MatchingCondItem.Validate if the designated constraints aren't met.
type MatchingCondItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchingCondItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchingCondItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchingCondItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchingCondItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchingCondItemValidationError) ErrorName() string { return "MatchingCondItemValidationError" }

// Error satisfies the builtin error interface
func (e MatchingCondItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchingCondItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchingCondItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchingCondItemValidationError{}

// Validate checks the field values on MatchingUeidList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MatchingUeidList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchingUeidList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MatchingUeidListMultiError, or nil if none found.
func (m *MatchingUeidList) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchingUeidList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchingUeidListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchingUeidListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchingUeidListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MatchingUeidListMultiError(errors)
	}
	return nil
}

// MatchingUeidListMultiError is an error wrapping multiple validation errors
// returned by MatchingUeidList.ValidateAll() if the designated constraints
// aren't met.
type MatchingUeidListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchingUeidListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchingUeidListMultiError) AllErrors() []error { return m }

// MatchingUeidListValidationError is the validation error returned by
// MatchingUeidList.Validate if the designated constraints aren't met.
type MatchingUeidListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchingUeidListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchingUeidListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchingUeidListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchingUeidListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchingUeidListValidationError) ErrorName() string { return "MatchingUeidListValidationError" }

// Error satisfies the builtin error interface
func (e MatchingUeidListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchingUeidList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchingUeidListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchingUeidListValidationError{}

// Validate checks the field values on MatchingUeidItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MatchingUeidItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchingUeidItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MatchingUeidItemMultiError, or nil if none found.
func (m *MatchingUeidItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchingUeidItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MatchingUeidItemValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MatchingUeidItemValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MatchingUeidItemValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MatchingUeidItemMultiError(errors)
	}
	return nil
}

// MatchingUeidItemMultiError is an error wrapping multiple validation errors
// returned by MatchingUeidItem.ValidateAll() if the designated constraints
// aren't met.
type MatchingUeidItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchingUeidItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchingUeidItemMultiError) AllErrors() []error { return m }

// MatchingUeidItemValidationError is the validation error returned by
// MatchingUeidItem.Validate if the designated constraints aren't met.
type MatchingUeidItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchingUeidItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchingUeidItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchingUeidItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchingUeidItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchingUeidItemValidationError) ErrorName() string { return "MatchingUeidItemValidationError" }

// Error satisfies the builtin error interface
func (e MatchingUeidItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchingUeidItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchingUeidItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchingUeidItemValidationError{}

// Validate checks the field values on E2SmKpmEventTriggerDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmEventTriggerDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmEventTriggerDefinition with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmKpmEventTriggerDefinitionMultiError, or nil if none found.
func (m *E2SmKpmEventTriggerDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmEventTriggerDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmKpmEventTriggerDefinition.(type) {

	case *E2SmKpmEventTriggerDefinition_EventDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetEventDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmEventTriggerDefinitionValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmEventTriggerDefinitionValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEventDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmKpmEventTriggerDefinitionMultiError(errors)
	}
	return nil
}

// E2SmKpmEventTriggerDefinitionMultiError is an error wrapping multiple
// validation errors returned by E2SmKpmEventTriggerDefinition.ValidateAll()
// if the designated constraints aren't met.
type E2SmKpmEventTriggerDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmEventTriggerDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmEventTriggerDefinitionMultiError) AllErrors() []error { return m }

// E2SmKpmEventTriggerDefinitionValidationError is the validation error
// returned by E2SmKpmEventTriggerDefinition.Validate if the designated
// constraints aren't met.
type E2SmKpmEventTriggerDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmEventTriggerDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmEventTriggerDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmEventTriggerDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmEventTriggerDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmEventTriggerDefinitionValidationError) ErrorName() string {
	return "E2SmKpmEventTriggerDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmEventTriggerDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmEventTriggerDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmEventTriggerDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmEventTriggerDefinitionValidationError{}

// Validate checks the field values on E2SmKpmEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *E2SmKpmEventTriggerDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// E2SmKpmEventTriggerDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmKpmEventTriggerDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmEventTriggerDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReportingPeriod

	if len(errors) > 0 {
		return E2SmKpmEventTriggerDefinitionFormat1MultiError(errors)
	}
	return nil
}

// E2SmKpmEventTriggerDefinitionFormat1MultiError is an error wrapping multiple
// validation errors returned by
// E2SmKpmEventTriggerDefinitionFormat1.ValidateAll() if the designated
// constraints aren't met.
type E2SmKpmEventTriggerDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmEventTriggerDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmEventTriggerDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmKpmEventTriggerDefinitionFormat1ValidationError is the validation error
// returned by E2SmKpmEventTriggerDefinitionFormat1.Validate if the designated
// constraints aren't met.
type E2SmKpmEventTriggerDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmEventTriggerDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmEventTriggerDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmEventTriggerDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmEventTriggerDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmEventTriggerDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmKpmEventTriggerDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmEventTriggerDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmEventTriggerDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmEventTriggerDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmEventTriggerDefinitionFormat1ValidationError{}

// Validate checks the field values on E2SmKpmActionDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmActionDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmActionDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmKpmActionDefinitionMultiError, or nil if none found.
func (m *E2SmKpmActionDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmActionDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionValidationError{
					field:  "RicStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionValidationError{
					field:  "RicStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionValidationError{
				field:  "RicStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.E2SmKpmActionDefinition.(type) {

	case *E2SmKpmActionDefinition_ActionDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetActionDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmActionDefinitionValidationError{
						field:  "ActionDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmActionDefinitionValidationError{
						field:  "ActionDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmActionDefinitionValidationError{
					field:  "ActionDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *E2SmKpmActionDefinition_ActionDefinitionFormat2:

		if all {
			switch v := interface{}(m.GetActionDefinitionFormat2()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmActionDefinitionValidationError{
						field:  "ActionDefinitionFormat2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmActionDefinitionValidationError{
						field:  "ActionDefinitionFormat2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionDefinitionFormat2()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmActionDefinitionValidationError{
					field:  "ActionDefinitionFormat2",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *E2SmKpmActionDefinition_ActionDefinitionFormat3:

		if all {
			switch v := interface{}(m.GetActionDefinitionFormat3()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmActionDefinitionValidationError{
						field:  "ActionDefinitionFormat3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmActionDefinitionValidationError{
						field:  "ActionDefinitionFormat3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionDefinitionFormat3()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmActionDefinitionValidationError{
					field:  "ActionDefinitionFormat3",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmKpmActionDefinitionMultiError(errors)
	}
	return nil
}

// E2SmKpmActionDefinitionMultiError is an error wrapping multiple validation
// errors returned by E2SmKpmActionDefinition.ValidateAll() if the designated
// constraints aren't met.
type E2SmKpmActionDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmActionDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmActionDefinitionMultiError) AllErrors() []error { return m }

// E2SmKpmActionDefinitionValidationError is the validation error returned by
// E2SmKpmActionDefinition.Validate if the designated constraints aren't met.
type E2SmKpmActionDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmActionDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmActionDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmActionDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmActionDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmActionDefinitionValidationError) ErrorName() string {
	return "E2SmKpmActionDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmActionDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmActionDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmActionDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmActionDefinitionValidationError{}

// Validate checks the field values on E2SmKpmActionDefinitionFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmActionDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmActionDefinitionFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmKpmActionDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmKpmActionDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmActionDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCellObjId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat1ValidationError{
				field:  "CellObjId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat1ValidationError{
				field:  "MeasInfoList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGranulPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat1ValidationError{
				field:  "GranulPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat1ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmKpmActionDefinitionFormat1MultiError(errors)
	}
	return nil
}

// E2SmKpmActionDefinitionFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmKpmActionDefinitionFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmKpmActionDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmActionDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmActionDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmKpmActionDefinitionFormat1ValidationError is the validation error
// returned by E2SmKpmActionDefinitionFormat1.Validate if the designated
// constraints aren't met.
type E2SmKpmActionDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmActionDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmActionDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmActionDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmActionDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmActionDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmKpmActionDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmActionDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmActionDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmActionDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmActionDefinitionFormat1ValidationError{}

// Validate checks the field values on E2SmKpmActionDefinitionFormat2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmActionDefinitionFormat2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmActionDefinitionFormat2 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmKpmActionDefinitionFormat2MultiError, or nil if none found.
func (m *E2SmKpmActionDefinitionFormat2) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmActionDefinitionFormat2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat2ValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat2ValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat2ValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscriptInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat2ValidationError{
					field:  "SubscriptInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat2ValidationError{
					field:  "SubscriptInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat2ValidationError{
				field:  "SubscriptInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmKpmActionDefinitionFormat2MultiError(errors)
	}
	return nil
}

// E2SmKpmActionDefinitionFormat2MultiError is an error wrapping multiple
// validation errors returned by E2SmKpmActionDefinitionFormat2.ValidateAll()
// if the designated constraints aren't met.
type E2SmKpmActionDefinitionFormat2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmActionDefinitionFormat2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmActionDefinitionFormat2MultiError) AllErrors() []error { return m }

// E2SmKpmActionDefinitionFormat2ValidationError is the validation error
// returned by E2SmKpmActionDefinitionFormat2.Validate if the designated
// constraints aren't met.
type E2SmKpmActionDefinitionFormat2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmActionDefinitionFormat2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmActionDefinitionFormat2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmActionDefinitionFormat2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmActionDefinitionFormat2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmActionDefinitionFormat2ValidationError) ErrorName() string {
	return "E2SmKpmActionDefinitionFormat2ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmActionDefinitionFormat2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmActionDefinitionFormat2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmActionDefinitionFormat2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmActionDefinitionFormat2ValidationError{}

// Validate checks the field values on E2SmKpmActionDefinitionFormat3 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmActionDefinitionFormat3) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmActionDefinitionFormat3 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmKpmActionDefinitionFormat3MultiError, or nil if none found.
func (m *E2SmKpmActionDefinitionFormat3) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmActionDefinitionFormat3) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCellObjId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat3ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat3ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat3ValidationError{
				field:  "CellObjId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasCondList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat3ValidationError{
					field:  "MeasCondList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat3ValidationError{
					field:  "MeasCondList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasCondList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat3ValidationError{
				field:  "MeasCondList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGranulPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat3ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat3ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat3ValidationError{
				field:  "GranulPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat3ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmActionDefinitionFormat3ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmActionDefinitionFormat3ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmKpmActionDefinitionFormat3MultiError(errors)
	}
	return nil
}

// E2SmKpmActionDefinitionFormat3MultiError is an error wrapping multiple
// validation errors returned by E2SmKpmActionDefinitionFormat3.ValidateAll()
// if the designated constraints aren't met.
type E2SmKpmActionDefinitionFormat3MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmActionDefinitionFormat3MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmActionDefinitionFormat3MultiError) AllErrors() []error { return m }

// E2SmKpmActionDefinitionFormat3ValidationError is the validation error
// returned by E2SmKpmActionDefinitionFormat3.Validate if the designated
// constraints aren't met.
type E2SmKpmActionDefinitionFormat3ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmActionDefinitionFormat3ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmActionDefinitionFormat3ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmActionDefinitionFormat3ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmActionDefinitionFormat3ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmActionDefinitionFormat3ValidationError) ErrorName() string {
	return "E2SmKpmActionDefinitionFormat3ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmActionDefinitionFormat3ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmActionDefinitionFormat3.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmActionDefinitionFormat3ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmActionDefinitionFormat3ValidationError{}

// Validate checks the field values on E2SmKpmIndicationHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmIndicationHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmIndicationHeader with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmKpmIndicationHeaderMultiError, or nil if none found.
func (m *E2SmKpmIndicationHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmIndicationHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmKpmIndicationHeader.(type) {

	case *E2SmKpmIndicationHeader_IndicationHeaderFormat1:

		if all {
			switch v := interface{}(m.GetIndicationHeaderFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmIndicationHeaderValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmIndicationHeaderValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationHeaderFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmIndicationHeaderValidationError{
					field:  "IndicationHeaderFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmKpmIndicationHeaderMultiError(errors)
	}
	return nil
}

// E2SmKpmIndicationHeaderMultiError is an error wrapping multiple validation
// errors returned by E2SmKpmIndicationHeader.ValidateAll() if the designated
// constraints aren't met.
type E2SmKpmIndicationHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmIndicationHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmIndicationHeaderMultiError) AllErrors() []error { return m }

// E2SmKpmIndicationHeaderValidationError is the validation error returned by
// E2SmKpmIndicationHeader.Validate if the designated constraints aren't met.
type E2SmKpmIndicationHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmIndicationHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmIndicationHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmIndicationHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmIndicationHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmIndicationHeaderValidationError) ErrorName() string {
	return "E2SmKpmIndicationHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmIndicationHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmIndicationHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmIndicationHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmIndicationHeaderValidationError{}

// Validate checks the field values on E2SmKpmIndicationHeaderFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmIndicationHeaderFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmIndicationHeaderFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmKpmIndicationHeaderFormat1MultiError, or nil if none found.
func (m *E2SmKpmIndicationHeaderFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmIndicationHeaderFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetColletStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationHeaderFormat1ValidationError{
					field:  "ColletStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationHeaderFormat1ValidationError{
					field:  "ColletStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetColletStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationHeaderFormat1ValidationError{
				field:  "ColletStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FileFormatversion

	// no validation rules for SenderName

	// no validation rules for SenderType

	// no validation rules for VendorName

	if all {
		switch v := interface{}(m.GetKpmNodeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationHeaderFormat1ValidationError{
					field:  "KpmNodeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationHeaderFormat1ValidationError{
					field:  "KpmNodeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKpmNodeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationHeaderFormat1ValidationError{
				field:  "KpmNodeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmKpmIndicationHeaderFormat1MultiError(errors)
	}
	return nil
}

// E2SmKpmIndicationHeaderFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmKpmIndicationHeaderFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmKpmIndicationHeaderFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmIndicationHeaderFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmIndicationHeaderFormat1MultiError) AllErrors() []error { return m }

// E2SmKpmIndicationHeaderFormat1ValidationError is the validation error
// returned by E2SmKpmIndicationHeaderFormat1.Validate if the designated
// constraints aren't met.
type E2SmKpmIndicationHeaderFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmIndicationHeaderFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmIndicationHeaderFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmIndicationHeaderFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmIndicationHeaderFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmIndicationHeaderFormat1ValidationError) ErrorName() string {
	return "E2SmKpmIndicationHeaderFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmIndicationHeaderFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmIndicationHeaderFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmIndicationHeaderFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmIndicationHeaderFormat1ValidationError{}

// Validate checks the field values on E2SmKpmIndicationMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmIndicationMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmIndicationMessage with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmKpmIndicationMessageMultiError, or nil if none found.
func (m *E2SmKpmIndicationMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmIndicationMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmKpmIndicationMessage.(type) {

	case *E2SmKpmIndicationMessage_IndicationMessageFormat1:

		if all {
			switch v := interface{}(m.GetIndicationMessageFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmIndicationMessageValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmIndicationMessageValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationMessageFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmIndicationMessageValidationError{
					field:  "IndicationMessageFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *E2SmKpmIndicationMessage_IndicationMessageFormat2:

		if all {
			switch v := interface{}(m.GetIndicationMessageFormat2()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmIndicationMessageValidationError{
						field:  "IndicationMessageFormat2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmIndicationMessageValidationError{
						field:  "IndicationMessageFormat2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationMessageFormat2()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmIndicationMessageValidationError{
					field:  "IndicationMessageFormat2",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmKpmIndicationMessageMultiError(errors)
	}
	return nil
}

// E2SmKpmIndicationMessageMultiError is an error wrapping multiple validation
// errors returned by E2SmKpmIndicationMessage.ValidateAll() if the designated
// constraints aren't met.
type E2SmKpmIndicationMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmIndicationMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmIndicationMessageMultiError) AllErrors() []error { return m }

// E2SmKpmIndicationMessageValidationError is the validation error returned by
// E2SmKpmIndicationMessage.Validate if the designated constraints aren't met.
type E2SmKpmIndicationMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmIndicationMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmIndicationMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmIndicationMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmIndicationMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmIndicationMessageValidationError) ErrorName() string {
	return "E2SmKpmIndicationMessageValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmIndicationMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmIndicationMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmIndicationMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmIndicationMessageValidationError{}

// Validate checks the field values on E2SmKpmIndicationMessageFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmIndicationMessageFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmIndicationMessageFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmKpmIndicationMessageFormat1MultiError, or nil if none found.
func (m *E2SmKpmIndicationMessageFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmIndicationMessageFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat1ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCellObjId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat1ValidationError{
				field:  "CellObjId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGranulPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat1ValidationError{
				field:  "GranulPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat1ValidationError{
				field:  "MeasInfoList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat1ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat1ValidationError{
				field:  "MeasData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmKpmIndicationMessageFormat1MultiError(errors)
	}
	return nil
}

// E2SmKpmIndicationMessageFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmKpmIndicationMessageFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmKpmIndicationMessageFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmIndicationMessageFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmIndicationMessageFormat1MultiError) AllErrors() []error { return m }

// E2SmKpmIndicationMessageFormat1ValidationError is the validation error
// returned by E2SmKpmIndicationMessageFormat1.Validate if the designated
// constraints aren't met.
type E2SmKpmIndicationMessageFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmIndicationMessageFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmIndicationMessageFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmIndicationMessageFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmIndicationMessageFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmIndicationMessageFormat1ValidationError) ErrorName() string {
	return "E2SmKpmIndicationMessageFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmIndicationMessageFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmIndicationMessageFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmIndicationMessageFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmIndicationMessageFormat1ValidationError{}

// Validate checks the field values on E2SmKpmIndicationMessageFormat2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmIndicationMessageFormat2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmIndicationMessageFormat2 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmKpmIndicationMessageFormat2MultiError, or nil if none found.
func (m *E2SmKpmIndicationMessageFormat2) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmIndicationMessageFormat2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat2ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCellObjId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat2ValidationError{
				field:  "CellObjId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGranulPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat2ValidationError{
				field:  "GranulPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasCondUeidList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "MeasCondUeidList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "MeasCondUeidList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasCondUeidList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat2ValidationError{
				field:  "MeasCondUeidList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmIndicationMessageFormat2ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmIndicationMessageFormat2ValidationError{
				field:  "MeasData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmKpmIndicationMessageFormat2MultiError(errors)
	}
	return nil
}

// E2SmKpmIndicationMessageFormat2MultiError is an error wrapping multiple
// validation errors returned by E2SmKpmIndicationMessageFormat2.ValidateAll()
// if the designated constraints aren't met.
type E2SmKpmIndicationMessageFormat2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmIndicationMessageFormat2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmIndicationMessageFormat2MultiError) AllErrors() []error { return m }

// E2SmKpmIndicationMessageFormat2ValidationError is the validation error
// returned by E2SmKpmIndicationMessageFormat2.Validate if the designated
// constraints aren't met.
type E2SmKpmIndicationMessageFormat2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmIndicationMessageFormat2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmIndicationMessageFormat2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmIndicationMessageFormat2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmIndicationMessageFormat2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmIndicationMessageFormat2ValidationError) ErrorName() string {
	return "E2SmKpmIndicationMessageFormat2ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmIndicationMessageFormat2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmIndicationMessageFormat2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmIndicationMessageFormat2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmIndicationMessageFormat2ValidationError{}

// Validate checks the field values on E2SmKpmRanfunctionDescription with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmKpmRanfunctionDescription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmKpmRanfunctionDescription with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmKpmRanfunctionDescriptionMultiError, or nil if none found.
func (m *E2SmKpmRanfunctionDescription) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmKpmRanfunctionDescription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRanFunctionName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmKpmRanfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmKpmRanfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRanFunctionName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmKpmRanfunctionDescriptionValidationError{
				field:  "RanFunctionName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetRicKpmNodeList()) > 1024 {
		err := E2SmKpmRanfunctionDescriptionValidationError{
			field:  "RicKpmNodeList",
			reason: "value must contain no more than 1024 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicKpmNodeList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicKpmNodeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicKpmNodeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicKpmNodeList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetRicEventTriggerStyleList()) > 63 {
		err := E2SmKpmRanfunctionDescriptionValidationError{
			field:  "RicEventTriggerStyleList",
			reason: "value must contain no more than 63 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicEventTriggerStyleList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetRicReportStyleList()) > 63 {
		err := E2SmKpmRanfunctionDescriptionValidationError{
			field:  "RicReportStyleList",
			reason: "value must contain no more than 63 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicReportStyleList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmKpmRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmKpmRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmKpmRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmKpmRanfunctionDescriptionMultiError(errors)
	}
	return nil
}

// E2SmKpmRanfunctionDescriptionMultiError is an error wrapping multiple
// validation errors returned by E2SmKpmRanfunctionDescription.ValidateAll()
// if the designated constraints aren't met.
type E2SmKpmRanfunctionDescriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmKpmRanfunctionDescriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmKpmRanfunctionDescriptionMultiError) AllErrors() []error { return m }

// E2SmKpmRanfunctionDescriptionValidationError is the validation error
// returned by E2SmKpmRanfunctionDescription.Validate if the designated
// constraints aren't met.
type E2SmKpmRanfunctionDescriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmKpmRanfunctionDescriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmKpmRanfunctionDescriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmKpmRanfunctionDescriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmKpmRanfunctionDescriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmKpmRanfunctionDescriptionValidationError) ErrorName() string {
	return "E2SmKpmRanfunctionDescriptionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmKpmRanfunctionDescriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmKpmRanfunctionDescription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmKpmRanfunctionDescriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmKpmRanfunctionDescriptionValidationError{}

// Validate checks the field values on RicKpmnodeItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicKpmnodeItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicKpmnodeItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicKpmnodeItemMultiError,
// or nil if none found.
func (m *RicKpmnodeItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicKpmnodeItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicKpmnodeType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicKpmnodeItemValidationError{
					field:  "RicKpmnodeType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicKpmnodeItemValidationError{
					field:  "RicKpmnodeType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicKpmnodeType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicKpmnodeItemValidationError{
				field:  "RicKpmnodeType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetCellMeasurementObjectList()) > 16384 {
		err := RicKpmnodeItemValidationError{
			field:  "CellMeasurementObjectList",
			reason: "value must contain no more than 16384 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCellMeasurementObjectList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RicKpmnodeItemValidationError{
						field:  fmt.Sprintf("CellMeasurementObjectList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RicKpmnodeItemValidationError{
						field:  fmt.Sprintf("CellMeasurementObjectList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RicKpmnodeItemValidationError{
					field:  fmt.Sprintf("CellMeasurementObjectList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RicKpmnodeItemMultiError(errors)
	}
	return nil
}

// RicKpmnodeItemMultiError is an error wrapping multiple validation errors
// returned by RicKpmnodeItem.ValidateAll() if the designated constraints
// aren't met.
type RicKpmnodeItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicKpmnodeItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicKpmnodeItemMultiError) AllErrors() []error { return m }

// RicKpmnodeItemValidationError is the validation error returned by
// RicKpmnodeItem.Validate if the designated constraints aren't met.
type RicKpmnodeItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicKpmnodeItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicKpmnodeItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicKpmnodeItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicKpmnodeItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicKpmnodeItemValidationError) ErrorName() string { return "RicKpmnodeItemValidationError" }

// Error satisfies the builtin error interface
func (e RicKpmnodeItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicKpmnodeItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicKpmnodeItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicKpmnodeItemValidationError{}

// Validate checks the field values on CellMeasurementObjectItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CellMeasurementObjectItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellMeasurementObjectItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CellMeasurementObjectItemMultiError, or nil if none found.
func (m *CellMeasurementObjectItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CellMeasurementObjectItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCellObjectId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CellMeasurementObjectItemValidationError{
					field:  "CellObjectId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CellMeasurementObjectItemValidationError{
					field:  "CellObjectId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjectId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CellMeasurementObjectItemValidationError{
				field:  "CellObjectId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCellGlobalId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CellMeasurementObjectItemValidationError{
					field:  "CellGlobalId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CellMeasurementObjectItemValidationError{
					field:  "CellGlobalId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellGlobalId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CellMeasurementObjectItemValidationError{
				field:  "CellGlobalId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CellMeasurementObjectItemMultiError(errors)
	}
	return nil
}

// CellMeasurementObjectItemMultiError is an error wrapping multiple validation
// errors returned by CellMeasurementObjectItem.ValidateAll() if the
// designated constraints aren't met.
type CellMeasurementObjectItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellMeasurementObjectItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellMeasurementObjectItemMultiError) AllErrors() []error { return m }

// CellMeasurementObjectItemValidationError is the validation error returned by
// CellMeasurementObjectItem.Validate if the designated constraints aren't met.
type CellMeasurementObjectItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellMeasurementObjectItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellMeasurementObjectItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellMeasurementObjectItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellMeasurementObjectItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellMeasurementObjectItemValidationError) ErrorName() string {
	return "CellMeasurementObjectItemValidationError"
}

// Error satisfies the builtin error interface
func (e CellMeasurementObjectItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellMeasurementObjectItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellMeasurementObjectItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellMeasurementObjectItemValidationError{}

// Validate checks the field values on RicEventTriggerStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RicEventTriggerStyleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicEventTriggerStyleItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicEventTriggerStyleItemMultiError, or nil if none found.
func (m *RicEventTriggerStyleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicEventTriggerStyleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicEventTriggerStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicEventTriggerStyleName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerStyleName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerStyleName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicEventTriggerFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RicEventTriggerStyleItemMultiError(errors)
	}
	return nil
}

// RicEventTriggerStyleItemMultiError is an error wrapping multiple validation
// errors returned by RicEventTriggerStyleItem.ValidateAll() if the designated
// constraints aren't met.
type RicEventTriggerStyleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicEventTriggerStyleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicEventTriggerStyleItemMultiError) AllErrors() []error { return m }

// RicEventTriggerStyleItemValidationError is the validation error returned by
// RicEventTriggerStyleItem.Validate if the designated constraints aren't met.
type RicEventTriggerStyleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicEventTriggerStyleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicEventTriggerStyleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicEventTriggerStyleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicEventTriggerStyleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicEventTriggerStyleItemValidationError) ErrorName() string {
	return "RicEventTriggerStyleItemValidationError"
}

// Error satisfies the builtin error interface
func (e RicEventTriggerStyleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicEventTriggerStyleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicEventTriggerStyleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicEventTriggerStyleItemValidationError{}

// Validate checks the field values on RicReportStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RicReportStyleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicReportStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicReportStyleItemMultiError, or nil if none found.
func (m *RicReportStyleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicReportStyleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicReportStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicReportStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicReportStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicReportStyleName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicReportStyleName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicReportStyleName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicActionFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicActionFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicActionFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicActionFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicActionFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoActionList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "MeasInfoActionList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "MeasInfoActionList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoActionList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "MeasInfoActionList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicIndicationHeaderFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationHeaderFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationHeaderFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicIndicationHeaderFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicIndicationHeaderFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicIndicationMessageFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationMessageFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationMessageFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicIndicationMessageFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicIndicationMessageFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RicReportStyleItemMultiError(errors)
	}
	return nil
}

// RicReportStyleItemMultiError is an error wrapping multiple validation errors
// returned by RicReportStyleItem.ValidateAll() if the designated constraints
// aren't met.
type RicReportStyleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicReportStyleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicReportStyleItemMultiError) AllErrors() []error { return m }

// RicReportStyleItemValidationError is the validation error returned by
// RicReportStyleItem.Validate if the designated constraints aren't met.
type RicReportStyleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicReportStyleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicReportStyleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicReportStyleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicReportStyleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicReportStyleItemValidationError) ErrorName() string {
	return "RicReportStyleItemValidationError"
}

// Error satisfies the builtin error interface
func (e RicReportStyleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicReportStyleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicReportStyleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicReportStyleItemValidationError{}

// Validate checks the field values on RicStyleName with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicStyleName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicStyleName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicStyleNameMultiError, or
// nil if none found.
func (m *RicStyleName) ValidateAll() error {
	return m.validate(true)
}

func (m *RicStyleName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := RicStyleNameValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicStyleNameMultiError(errors)
	}
	return nil
}

// RicStyleNameMultiError is an error wrapping multiple validation errors
// returned by RicStyleName.ValidateAll() if the designated constraints aren't met.
type RicStyleNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicStyleNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicStyleNameMultiError) AllErrors() []error { return m }

// RicStyleNameValidationError is the validation error returned by
// RicStyleName.Validate if the designated constraints aren't met.
type RicStyleNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicStyleNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicStyleNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicStyleNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicStyleNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicStyleNameValidationError) ErrorName() string { return "RicStyleNameValidationError" }

// Error satisfies the builtin error interface
func (e RicStyleNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicStyleName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicStyleNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicStyleNameValidationError{}

// Validate checks the field values on CellObjectId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CellObjectId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellObjectId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CellObjectIdMultiError, or
// nil if none found.
func (m *CellObjectId) ValidateAll() error {
	return m.validate(true)
}

func (m *CellObjectId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 0 || l > 400 {
		err := CellObjectIdValidationError{
			field:  "Value",
			reason: "value length must be between 0 and 400 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CellObjectIdMultiError(errors)
	}
	return nil
}

// CellObjectIdMultiError is an error wrapping multiple validation errors
// returned by CellObjectId.ValidateAll() if the designated constraints aren't met.
type CellObjectIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellObjectIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellObjectIdMultiError) AllErrors() []error { return m }

// CellObjectIdValidationError is the validation error returned by
// CellObjectId.Validate if the designated constraints aren't met.
type CellObjectIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellObjectIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellObjectIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellObjectIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellObjectIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellObjectIdValidationError) ErrorName() string { return "CellObjectIdValidationError" }

// Error satisfies the builtin error interface
func (e CellObjectIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellObjectId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellObjectIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellObjectIdValidationError{}

// Validate checks the field values on MeasurementTypeName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementTypeName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementTypeName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeNameMultiError, or nil if none found.
func (m *MeasurementTypeName) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementTypeName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := MeasurementTypeNameValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementTypeNameMultiError(errors)
	}
	return nil
}

// MeasurementTypeNameMultiError is an error wrapping multiple validation
// errors returned by MeasurementTypeName.ValidateAll() if the designated
// constraints aren't met.
type MeasurementTypeNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeNameMultiError) AllErrors() []error { return m }

// MeasurementTypeNameValidationError is the validation error returned by
// MeasurementTypeName.Validate if the designated constraints aren't met.
type MeasurementTypeNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeNameValidationError) ErrorName() string {
	return "MeasurementTypeNameValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementTypeNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementTypeName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeNameValidationError{}

// Validate checks the field values on UeIdentity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UeIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UeIdentity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UeIdentityMultiError, or
// nil if none found.
func (m *UeIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *UeIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return UeIdentityMultiError(errors)
	}
	return nil
}

// UeIdentityMultiError is an error wrapping multiple validation errors
// returned by UeIdentity.ValidateAll() if the designated constraints aren't met.
type UeIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeIdentityMultiError) AllErrors() []error { return m }

// UeIdentityValidationError is the validation error returned by
// UeIdentity.Validate if the designated constraints aren't met.
type UeIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeIdentityValidationError) ErrorName() string { return "UeIdentityValidationError" }

// Error satisfies the builtin error interface
func (e UeIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeIdentityValidationError{}

// Validate checks the field values on PlmnIdentity with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlmnIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlmnIdentity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlmnIdentityMultiError, or
// nil if none found.
func (m *PlmnIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *PlmnIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 3 {
		err := PlmnIdentityValidationError{
			field:  "Value",
			reason: "value length must be 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PlmnIdentityMultiError(errors)
	}
	return nil
}

// PlmnIdentityMultiError is an error wrapping multiple validation errors
// returned by PlmnIdentity.ValidateAll() if the designated constraints aren't met.
type PlmnIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlmnIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlmnIdentityMultiError) AllErrors() []error { return m }

// PlmnIdentityValidationError is the validation error returned by
// PlmnIdentity.Validate if the designated constraints aren't met.
type PlmnIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlmnIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlmnIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlmnIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlmnIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlmnIdentityValidationError) ErrorName() string { return "PlmnIdentityValidationError" }

// Error satisfies the builtin error interface
func (e PlmnIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlmnIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlmnIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlmnIdentityValidationError{}

// Validate checks the field values on TimeStamp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeStamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeStamp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeStampMultiError, or nil
// if none found.
func (m *TimeStamp) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeStamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 4 {
		err := TimeStampValidationError{
			field:  "Value",
			reason: "value length must be 4 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TimeStampMultiError(errors)
	}
	return nil
}

// TimeStampMultiError is an error wrapping multiple validation errors returned
// by TimeStamp.ValidateAll() if the designated constraints aren't met.
type TimeStampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeStampMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeStampMultiError) AllErrors() []error { return m }

// TimeStampValidationError is the validation error returned by
// TimeStamp.Validate if the designated constraints aren't met.
type TimeStampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeStampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeStampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeStampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeStampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeStampValidationError) ErrorName() string { return "TimeStampValidationError" }

// Error satisfies the builtin error interface
func (e TimeStampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeStamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeStampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeStampValidationError{}

// Validate checks the field values on EutracellIdentity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EutracellIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EutracellIdentity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EutracellIdentityMultiError, or nil if none found.
func (m *EutracellIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *EutracellIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EutracellIdentityValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EutracellIdentityValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EutracellIdentityValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EutracellIdentityMultiError(errors)
	}
	return nil
}

// EutracellIdentityMultiError is an error wrapping multiple validation errors
// returned by EutracellIdentity.ValidateAll() if the designated constraints
// aren't met.
type EutracellIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EutracellIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EutracellIdentityMultiError) AllErrors() []error { return m }

// EutracellIdentityValidationError is the validation error returned by
// EutracellIdentity.Validate if the designated constraints aren't met.
type EutracellIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EutracellIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EutracellIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EutracellIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EutracellIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EutracellIdentityValidationError) ErrorName() string {
	return "EutracellIdentityValidationError"
}

// Error satisfies the builtin error interface
func (e EutracellIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEutracellIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EutracellIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EutracellIdentityValidationError{}

// Validate checks the field values on NrcellIdentity with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NrcellIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NrcellIdentity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NrcellIdentityMultiError,
// or nil if none found.
func (m *NrcellIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *NrcellIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NrcellIdentityValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NrcellIdentityValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NrcellIdentityValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NrcellIdentityMultiError(errors)
	}
	return nil
}

// NrcellIdentityMultiError is an error wrapping multiple validation errors
// returned by NrcellIdentity.ValidateAll() if the designated constraints
// aren't met.
type NrcellIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NrcellIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NrcellIdentityMultiError) AllErrors() []error { return m }

// NrcellIdentityValidationError is the validation error returned by
// NrcellIdentity.Validate if the designated constraints aren't met.
type NrcellIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NrcellIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NrcellIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NrcellIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NrcellIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NrcellIdentityValidationError) ErrorName() string { return "NrcellIdentityValidationError" }

// Error satisfies the builtin error interface
func (e NrcellIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNrcellIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NrcellIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NrcellIdentityValidationError{}

// Validate checks the field values on BitString with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BitString) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BitString with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BitStringMultiError, or nil
// if none found.
func (m *BitString) ValidateAll() error {
	return m.validate(true)
}

func (m *BitString) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Len

	if len(errors) > 0 {
		return BitStringMultiError(errors)
	}
	return nil
}

// BitStringMultiError is an error wrapping multiple validation errors returned
// by BitString.ValidateAll() if the designated constraints aren't met.
type BitStringMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BitStringMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BitStringMultiError) AllErrors() []error { return m }

// BitStringValidationError is the validation error returned by
// BitString.Validate if the designated constraints aren't met.
type BitStringValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BitStringValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BitStringValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BitStringValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BitStringValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BitStringValidationError) ErrorName() string { return "BitStringValidationError" }

// Error satisfies the builtin error interface
func (e BitStringValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBitString.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BitStringValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BitStringValidationError{}
