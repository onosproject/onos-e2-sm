// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: e2sm_rsm/v1/e2sm_rsm_v1.proto

package e2smrsmies

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on MaxnoofBearers with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxnoofBearers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofBearers with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MaxnoofBearersMultiError,
// or nil if none found.
func (m *MaxnoofBearers) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofBearers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 32 {
		err := MaxnoofBearersValidationError{
			field:  "Value",
			reason: "value must equal 32",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofBearersMultiError(errors)
	}

	return nil
}

// MaxnoofBearersMultiError is an error wrapping multiple validation errors
// returned by MaxnoofBearers.ValidateAll() if the designated constraints
// aren't met.
type MaxnoofBearersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofBearersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofBearersMultiError) AllErrors() []error { return m }

// MaxnoofBearersValidationError is the validation error returned by
// MaxnoofBearers.Validate if the designated constraints aren't met.
type MaxnoofBearersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofBearersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofBearersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofBearersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofBearersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofBearersValidationError) ErrorName() string { return "MaxnoofBearersValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofBearersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofBearers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofBearersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofBearersValidationError{}

// Validate checks the field values on MaxnoofUes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxnoofUes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofUes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MaxnoofUesMultiError, or
// nil if none found.
func (m *MaxnoofUes) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofUes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != -1 {
		err := MaxnoofUesValidationError{
			field:  "Value",
			reason: "value must equal -1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofUesMultiError(errors)
	}

	return nil
}

// MaxnoofUesMultiError is an error wrapping multiple validation errors
// returned by MaxnoofUes.ValidateAll() if the designated constraints aren't met.
type MaxnoofUesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofUesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofUesMultiError) AllErrors() []error { return m }

// MaxnoofUesValidationError is the validation error returned by
// MaxnoofUes.Validate if the designated constraints aren't met.
type MaxnoofUesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofUesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofUesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofUesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofUesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofUesValidationError) ErrorName() string { return "MaxnoofUesValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofUesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofUes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofUesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofUesValidationError{}

// Validate checks the field values on MaxnoofSlices with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxnoofSlices) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofSlices with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MaxnoofSlicesMultiError, or
// nil if none found.
func (m *MaxnoofSlices) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofSlices) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != -1 {
		err := MaxnoofSlicesValidationError{
			field:  "Value",
			reason: "value must equal -1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofSlicesMultiError(errors)
	}

	return nil
}

// MaxnoofSlicesMultiError is an error wrapping multiple validation errors
// returned by MaxnoofSlices.ValidateAll() if the designated constraints
// aren't met.
type MaxnoofSlicesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofSlicesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofSlicesMultiError) AllErrors() []error { return m }

// MaxnoofSlicesValidationError is the validation error returned by
// MaxnoofSlices.Validate if the designated constraints aren't met.
type MaxnoofSlicesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofSlicesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofSlicesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofSlicesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofSlicesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofSlicesValidationError) ErrorName() string { return "MaxnoofSlicesValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofSlicesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofSlices.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofSlicesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofSlicesValidationError{}

// Validate checks the field values on SliceId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SliceId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SliceIdMultiError, or nil if none found.
func (m *SliceId) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := SliceIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SliceIdMultiError(errors)
	}

	return nil
}

// SliceIdMultiError is an error wrapping multiple validation errors returned
// by SliceId.ValidateAll() if the designated constraints aren't met.
type SliceIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceIdMultiError) AllErrors() []error { return m }

// SliceIdValidationError is the validation error returned by SliceId.Validate
// if the designated constraints aren't met.
type SliceIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceIdValidationError) ErrorName() string { return "SliceIdValidationError" }

// Error satisfies the builtin error interface
func (e SliceIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceIdValidationError{}

// Validate checks the field values on SliceIdassoc with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SliceIdassoc) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceIdassoc with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SliceIdassocMultiError, or
// nil if none found.
func (m *SliceIdassoc) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceIdassoc) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 4294967295 {
		err := SliceIdassocValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SliceIdassocMultiError(errors)
	}

	return nil
}

// SliceIdassocMultiError is an error wrapping multiple validation errors
// returned by SliceIdassoc.ValidateAll() if the designated constraints aren't met.
type SliceIdassocMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceIdassocMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceIdassocMultiError) AllErrors() []error { return m }

// SliceIdassocValidationError is the validation error returned by
// SliceIdassoc.Validate if the designated constraints aren't met.
type SliceIdassocValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceIdassocValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceIdassocValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceIdassocValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceIdassocValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceIdassocValidationError) ErrorName() string { return "SliceIdassocValidationError" }

// Error satisfies the builtin error interface
func (e SliceIdassocValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceIdassoc.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceIdassocValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceIdassocValidationError{}

// Validate checks the field values on UeIdentity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UeIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UeIdentity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UeIdentityMultiError, or
// nil if none found.
func (m *UeIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *UeIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.UeIdentity.(type) {

	case *UeIdentity_CuUeF1ApId:

		if all {
			switch v := interface{}(m.GetCuUeF1ApId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "CuUeF1ApId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "CuUeF1ApId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCuUeF1ApId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UeIdentityValidationError{
					field:  "CuUeF1ApId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *UeIdentity_DuUeF1ApId:

		if all {
			switch v := interface{}(m.GetDuUeF1ApId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "DuUeF1ApId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "DuUeF1ApId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDuUeF1ApId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UeIdentityValidationError{
					field:  "DuUeF1ApId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *UeIdentity_RanUeNgapId:

		if all {
			switch v := interface{}(m.GetRanUeNgapId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "RanUeNgapId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "RanUeNgapId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRanUeNgapId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UeIdentityValidationError{
					field:  "RanUeNgapId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *UeIdentity_AmfUeNgapId:

		if all {
			switch v := interface{}(m.GetAmfUeNgapId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "AmfUeNgapId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "AmfUeNgapId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAmfUeNgapId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UeIdentityValidationError{
					field:  "AmfUeNgapId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *UeIdentity_EnbUeS1ApId:

		if all {
			switch v := interface{}(m.GetEnbUeS1ApId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "EnbUeS1ApId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UeIdentityValidationError{
						field:  "EnbUeS1ApId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnbUeS1ApId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UeIdentityValidationError{
					field:  "EnbUeS1ApId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UeIdentityMultiError(errors)
	}

	return nil
}

// UeIdentityMultiError is an error wrapping multiple validation errors
// returned by UeIdentity.ValidateAll() if the designated constraints aren't met.
type UeIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeIdentityMultiError) AllErrors() []error { return m }

// UeIdentityValidationError is the validation error returned by
// UeIdentity.Validate if the designated constraints aren't met.
type UeIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeIdentityValidationError) ErrorName() string { return "UeIdentityValidationError" }

// Error satisfies the builtin error interface
func (e UeIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeIdentityValidationError{}

// Validate checks the field values on CuUeF1ApId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CuUeF1ApId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CuUeF1ApId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CuUeF1ApIdMultiError, or
// nil if none found.
func (m *CuUeF1ApId) ValidateAll() error {
	return m.validate(true)
}

func (m *CuUeF1ApId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 4294967295 {
		err := CuUeF1ApIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CuUeF1ApIdMultiError(errors)
	}

	return nil
}

// CuUeF1ApIdMultiError is an error wrapping multiple validation errors
// returned by CuUeF1ApId.ValidateAll() if the designated constraints aren't met.
type CuUeF1ApIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CuUeF1ApIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CuUeF1ApIdMultiError) AllErrors() []error { return m }

// CuUeF1ApIdValidationError is the validation error returned by
// CuUeF1ApId.Validate if the designated constraints aren't met.
type CuUeF1ApIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CuUeF1ApIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CuUeF1ApIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CuUeF1ApIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CuUeF1ApIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CuUeF1ApIdValidationError) ErrorName() string { return "CuUeF1ApIdValidationError" }

// Error satisfies the builtin error interface
func (e CuUeF1ApIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCuUeF1ApId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CuUeF1ApIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CuUeF1ApIdValidationError{}

// Validate checks the field values on DuUeF1ApId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DuUeF1ApId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DuUeF1ApId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DuUeF1ApIdMultiError, or
// nil if none found.
func (m *DuUeF1ApId) ValidateAll() error {
	return m.validate(true)
}

func (m *DuUeF1ApId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 4294967295 {
		err := DuUeF1ApIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DuUeF1ApIdMultiError(errors)
	}

	return nil
}

// DuUeF1ApIdMultiError is an error wrapping multiple validation errors
// returned by DuUeF1ApId.ValidateAll() if the designated constraints aren't met.
type DuUeF1ApIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DuUeF1ApIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DuUeF1ApIdMultiError) AllErrors() []error { return m }

// DuUeF1ApIdValidationError is the validation error returned by
// DuUeF1ApId.Validate if the designated constraints aren't met.
type DuUeF1ApIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DuUeF1ApIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DuUeF1ApIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DuUeF1ApIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DuUeF1ApIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DuUeF1ApIdValidationError) ErrorName() string { return "DuUeF1ApIdValidationError" }

// Error satisfies the builtin error interface
func (e DuUeF1ApIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDuUeF1ApId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DuUeF1ApIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DuUeF1ApIdValidationError{}

// Validate checks the field values on RanUeNgapId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RanUeNgapId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RanUeNgapId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RanUeNgapIdMultiError, or
// nil if none found.
func (m *RanUeNgapId) ValidateAll() error {
	return m.validate(true)
}

func (m *RanUeNgapId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 1099511627775 {
		err := RanUeNgapIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 1099511627775]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RanUeNgapIdMultiError(errors)
	}

	return nil
}

// RanUeNgapIdMultiError is an error wrapping multiple validation errors
// returned by RanUeNgapId.ValidateAll() if the designated constraints aren't met.
type RanUeNgapIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RanUeNgapIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RanUeNgapIdMultiError) AllErrors() []error { return m }

// RanUeNgapIdValidationError is the validation error returned by
// RanUeNgapId.Validate if the designated constraints aren't met.
type RanUeNgapIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RanUeNgapIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RanUeNgapIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RanUeNgapIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RanUeNgapIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RanUeNgapIdValidationError) ErrorName() string { return "RanUeNgapIdValidationError" }

// Error satisfies the builtin error interface
func (e RanUeNgapIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRanUeNgapId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RanUeNgapIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RanUeNgapIdValidationError{}

// Validate checks the field values on EnbUeS1ApId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnbUeS1ApId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnbUeS1ApId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnbUeS1ApIdMultiError, or
// nil if none found.
func (m *EnbUeS1ApId) ValidateAll() error {
	return m.validate(true)
}

func (m *EnbUeS1ApId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 16777215 {
		err := EnbUeS1ApIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 16777215]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EnbUeS1ApIdMultiError(errors)
	}

	return nil
}

// EnbUeS1ApIdMultiError is an error wrapping multiple validation errors
// returned by EnbUeS1ApId.ValidateAll() if the designated constraints aren't met.
type EnbUeS1ApIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnbUeS1ApIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnbUeS1ApIdMultiError) AllErrors() []error { return m }

// EnbUeS1ApIdValidationError is the validation error returned by
// EnbUeS1ApId.Validate if the designated constraints aren't met.
type EnbUeS1ApIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnbUeS1ApIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnbUeS1ApIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnbUeS1ApIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnbUeS1ApIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnbUeS1ApIdValidationError) ErrorName() string { return "EnbUeS1ApIdValidationError" }

// Error satisfies the builtin error interface
func (e EnbUeS1ApIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnbUeS1ApId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnbUeS1ApIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnbUeS1ApIdValidationError{}

// Validate checks the field values on Qfi with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Qfi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Qfi with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QfiMultiError, or nil if none found.
func (m *Qfi) ValidateAll() error {
	return m.validate(true)
}

func (m *Qfi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 63 {
		err := QfiValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 63]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QfiMultiError(errors)
	}

	return nil
}

// QfiMultiError is an error wrapping multiple validation errors returned by
// Qfi.ValidateAll() if the designated constraints aren't met.
type QfiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QfiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QfiMultiError) AllErrors() []error { return m }

// QfiValidationError is the validation error returned by Qfi.Validate if the
// designated constraints aren't met.
type QfiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QfiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QfiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QfiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QfiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QfiValidationError) ErrorName() string { return "QfiValidationError" }

// Error satisfies the builtin error interface
func (e QfiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQfi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QfiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QfiValidationError{}

// Validate checks the field values on MaxnoofSlicingNodes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofSlicingNodes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofSlicingNodes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofSlicingNodesMultiError, or nil if none found.
func (m *MaxnoofSlicingNodes) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofSlicingNodes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != -1 {
		err := MaxnoofSlicingNodesValidationError{
			field:  "Value",
			reason: "value must equal -1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofSlicingNodesMultiError(errors)
	}

	return nil
}

// MaxnoofSlicingNodesMultiError is an error wrapping multiple validation
// errors returned by MaxnoofSlicingNodes.ValidateAll() if the designated
// constraints aren't met.
type MaxnoofSlicingNodesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofSlicingNodesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofSlicingNodesMultiError) AllErrors() []error { return m }

// MaxnoofSlicingNodesValidationError is the validation error returned by
// MaxnoofSlicingNodes.Validate if the designated constraints aren't met.
type MaxnoofSlicingNodesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofSlicingNodesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofSlicingNodesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofSlicingNodesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofSlicingNodesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofSlicingNodesValidationError) ErrorName() string {
	return "MaxnoofSlicingNodesValidationError"
}

// Error satisfies the builtin error interface
func (e MaxnoofSlicingNodesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofSlicingNodes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofSlicingNodesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofSlicingNodesValidationError{}

// Validate checks the field values on NodeSlicingCapabilityItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeSlicingCapabilityItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSlicingCapabilityItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeSlicingCapabilityItemMultiError, or nil if none found.
func (m *NodeSlicingCapabilityItem) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSlicingCapabilityItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxNumberOfSlicesDl

	// no validation rules for MaxNumberOfSlicesUl

	// no validation rules for SlicingType

	// no validation rules for MaxNumberOfUesPerSlice

	if l := len(m.GetSupportedConfig()); l < 1 || l > 5 {
		err := NodeSlicingCapabilityItemValidationError{
			field:  "SupportedConfig",
			reason: "value must contain between 1 and 5 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSupportedConfig() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeSlicingCapabilityItemValidationError{
						field:  fmt.Sprintf("SupportedConfig[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeSlicingCapabilityItemValidationError{
						field:  fmt.Sprintf("SupportedConfig[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeSlicingCapabilityItemValidationError{
					field:  fmt.Sprintf("SupportedConfig[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeSlicingCapabilityItemMultiError(errors)
	}

	return nil
}

// NodeSlicingCapabilityItemMultiError is an error wrapping multiple validation
// errors returned by NodeSlicingCapabilityItem.ValidateAll() if the
// designated constraints aren't met.
type NodeSlicingCapabilityItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSlicingCapabilityItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSlicingCapabilityItemMultiError) AllErrors() []error { return m }

// NodeSlicingCapabilityItemValidationError is the validation error returned by
// NodeSlicingCapabilityItem.Validate if the designated constraints aren't met.
type NodeSlicingCapabilityItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSlicingCapabilityItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSlicingCapabilityItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSlicingCapabilityItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSlicingCapabilityItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSlicingCapabilityItemValidationError) ErrorName() string {
	return "NodeSlicingCapabilityItemValidationError"
}

// Error satisfies the builtin error interface
func (e NodeSlicingCapabilityItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSlicingCapabilityItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSlicingCapabilityItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSlicingCapabilityItemValidationError{}

// Validate checks the field values on SupportedSlicingConfigItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SupportedSlicingConfigItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SupportedSlicingConfigItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SupportedSlicingConfigItemMultiError, or nil if none found.
func (m *SupportedSlicingConfigItem) ValidateAll() error {
	return m.validate(true)
}

func (m *SupportedSlicingConfigItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SlicingConfigType

	if len(errors) > 0 {
		return SupportedSlicingConfigItemMultiError(errors)
	}

	return nil
}

// SupportedSlicingConfigItemMultiError is an error wrapping multiple
// validation errors returned by SupportedSlicingConfigItem.ValidateAll() if
// the designated constraints aren't met.
type SupportedSlicingConfigItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SupportedSlicingConfigItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SupportedSlicingConfigItemMultiError) AllErrors() []error { return m }

// SupportedSlicingConfigItemValidationError is the validation error returned
// by SupportedSlicingConfigItem.Validate if the designated constraints aren't met.
type SupportedSlicingConfigItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SupportedSlicingConfigItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SupportedSlicingConfigItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SupportedSlicingConfigItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SupportedSlicingConfigItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SupportedSlicingConfigItemValidationError) ErrorName() string {
	return "SupportedSlicingConfigItemValidationError"
}

// Error satisfies the builtin error interface
func (e SupportedSlicingConfigItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSupportedSlicingConfigItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SupportedSlicingConfigItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SupportedSlicingConfigItemValidationError{}

// Validate checks the field values on SliceMetrics with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SliceMetrics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceMetrics with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SliceMetricsMultiError, or
// nil if none found.
func (m *SliceMetrics) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceMetrics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PrbUtilization

	// no validation rules for NumUeAssocToSlice

	// no validation rules for SliceLevelBler

	// no validation rules for AvgCqi

	if len(errors) > 0 {
		return SliceMetricsMultiError(errors)
	}

	return nil
}

// SliceMetricsMultiError is an error wrapping multiple validation errors
// returned by SliceMetrics.ValidateAll() if the designated constraints aren't met.
type SliceMetricsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceMetricsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceMetricsMultiError) AllErrors() []error { return m }

// SliceMetricsValidationError is the validation error returned by
// SliceMetrics.Validate if the designated constraints aren't met.
type SliceMetricsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceMetricsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceMetricsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceMetricsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceMetricsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceMetricsValidationError) ErrorName() string { return "SliceMetricsValidationError" }

// Error satisfies the builtin error interface
func (e SliceMetricsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceMetrics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceMetricsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceMetricsValidationError{}

// Validate checks the field values on E2SmRsmEventTriggerDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmEventTriggerDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmEventTriggerDefinition with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRsmEventTriggerDefinitionMultiError, or nil if none found.
func (m *E2SmRsmEventTriggerDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmEventTriggerDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEventDefinitionFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRsmEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRsmEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDefinitionFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRsmEventTriggerDefinitionValidationError{
				field:  "EventDefinitionFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmRsmEventTriggerDefinitionMultiError(errors)
	}

	return nil
}

// E2SmRsmEventTriggerDefinitionMultiError is an error wrapping multiple
// validation errors returned by E2SmRsmEventTriggerDefinition.ValidateAll()
// if the designated constraints aren't met.
type E2SmRsmEventTriggerDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmEventTriggerDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmEventTriggerDefinitionMultiError) AllErrors() []error { return m }

// E2SmRsmEventTriggerDefinitionValidationError is the validation error
// returned by E2SmRsmEventTriggerDefinition.Validate if the designated
// constraints aren't met.
type E2SmRsmEventTriggerDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmEventTriggerDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmEventTriggerDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmEventTriggerDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmEventTriggerDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmEventTriggerDefinitionValidationError) ErrorName() string {
	return "E2SmRsmEventTriggerDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmEventTriggerDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmEventTriggerDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmEventTriggerDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmEventTriggerDefinitionValidationError{}

// Validate checks the field values on EventDefinitionFormats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventDefinitionFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventDefinitionFormats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EventDefinitionFormatsMultiError, or nil if none found.
func (m *EventDefinitionFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *EventDefinitionFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmRsmEventDefinition.(type) {

	case *EventDefinitionFormats_EventDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetEventDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDefinitionFormatsValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDefinitionFormatsValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEventDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDefinitionFormatsValidationError{
					field:  "EventDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EventDefinitionFormatsMultiError(errors)
	}

	return nil
}

// EventDefinitionFormatsMultiError is an error wrapping multiple validation
// errors returned by EventDefinitionFormats.ValidateAll() if the designated
// constraints aren't met.
type EventDefinitionFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventDefinitionFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventDefinitionFormatsMultiError) AllErrors() []error { return m }

// EventDefinitionFormatsValidationError is the validation error returned by
// EventDefinitionFormats.Validate if the designated constraints aren't met.
type EventDefinitionFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventDefinitionFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventDefinitionFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventDefinitionFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventDefinitionFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventDefinitionFormatsValidationError) ErrorName() string {
	return "EventDefinitionFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e EventDefinitionFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventDefinitionFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventDefinitionFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventDefinitionFormatsValidationError{}

// Validate checks the field values on E2SmRsmEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *E2SmRsmEventTriggerDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// E2SmRsmEventTriggerDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmRsmEventTriggerDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmEventTriggerDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TriggerType

	if m.ReportingPeriodMs != nil {
		// no validation rules for ReportingPeriodMs
	}

	if len(errors) > 0 {
		return E2SmRsmEventTriggerDefinitionFormat1MultiError(errors)
	}

	return nil
}

// E2SmRsmEventTriggerDefinitionFormat1MultiError is an error wrapping multiple
// validation errors returned by
// E2SmRsmEventTriggerDefinitionFormat1.ValidateAll() if the designated
// constraints aren't met.
type E2SmRsmEventTriggerDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmEventTriggerDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmEventTriggerDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmRsmEventTriggerDefinitionFormat1ValidationError is the validation error
// returned by E2SmRsmEventTriggerDefinitionFormat1.Validate if the designated
// constraints aren't met.
type E2SmRsmEventTriggerDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmEventTriggerDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmEventTriggerDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmEventTriggerDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmEventTriggerDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmEventTriggerDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmRsmEventTriggerDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmEventTriggerDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmEventTriggerDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmEventTriggerDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmEventTriggerDefinitionFormat1ValidationError{}

// Validate checks the field values on E2SmRsmIndicationHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmIndicationHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmIndicationHeader with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmRsmIndicationHeaderMultiError, or nil if none found.
func (m *E2SmRsmIndicationHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmIndicationHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmRsmIndicationHeader.(type) {

	case *E2SmRsmIndicationHeader_IndicationHeaderFormat1:

		if all {
			switch v := interface{}(m.GetIndicationHeaderFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmIndicationHeaderValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmIndicationHeaderValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationHeaderFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmIndicationHeaderValidationError{
					field:  "IndicationHeaderFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRsmIndicationHeaderMultiError(errors)
	}

	return nil
}

// E2SmRsmIndicationHeaderMultiError is an error wrapping multiple validation
// errors returned by E2SmRsmIndicationHeader.ValidateAll() if the designated
// constraints aren't met.
type E2SmRsmIndicationHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmIndicationHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmIndicationHeaderMultiError) AllErrors() []error { return m }

// E2SmRsmIndicationHeaderValidationError is the validation error returned by
// E2SmRsmIndicationHeader.Validate if the designated constraints aren't met.
type E2SmRsmIndicationHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmIndicationHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmIndicationHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmIndicationHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmIndicationHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmIndicationHeaderValidationError) ErrorName() string {
	return "E2SmRsmIndicationHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmIndicationHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmIndicationHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmIndicationHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmIndicationHeaderValidationError{}

// Validate checks the field values on E2SmRsmIndicationHeaderFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmIndicationHeaderFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmIndicationHeaderFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRsmIndicationHeaderFormat1MultiError, or nil if none found.
func (m *E2SmRsmIndicationHeaderFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmIndicationHeaderFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCgi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRsmIndicationHeaderFormat1ValidationError{
					field:  "Cgi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRsmIndicationHeaderFormat1ValidationError{
					field:  "Cgi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCgi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRsmIndicationHeaderFormat1ValidationError{
				field:  "Cgi",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.ColletStartTime != nil {
		// no validation rules for ColletStartTime
	}

	if len(errors) > 0 {
		return E2SmRsmIndicationHeaderFormat1MultiError(errors)
	}

	return nil
}

// E2SmRsmIndicationHeaderFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmRsmIndicationHeaderFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmRsmIndicationHeaderFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmIndicationHeaderFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmIndicationHeaderFormat1MultiError) AllErrors() []error { return m }

// E2SmRsmIndicationHeaderFormat1ValidationError is the validation error
// returned by E2SmRsmIndicationHeaderFormat1.Validate if the designated
// constraints aren't met.
type E2SmRsmIndicationHeaderFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmIndicationHeaderFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmIndicationHeaderFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmIndicationHeaderFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmIndicationHeaderFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmIndicationHeaderFormat1ValidationError) ErrorName() string {
	return "E2SmRsmIndicationHeaderFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmIndicationHeaderFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmIndicationHeaderFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmIndicationHeaderFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmIndicationHeaderFormat1ValidationError{}

// Validate checks the field values on E2SmRsmIndicationMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmIndicationMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmIndicationMessage with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmRsmIndicationMessageMultiError, or nil if none found.
func (m *E2SmRsmIndicationMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmIndicationMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmRsmIndicationMessage.(type) {

	case *E2SmRsmIndicationMessage_IndicationMessageFormat1:

		if all {
			switch v := interface{}(m.GetIndicationMessageFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationMessageFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmIndicationMessageValidationError{
					field:  "IndicationMessageFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *E2SmRsmIndicationMessage_IndicationMessageFormat2:

		if all {
			switch v := interface{}(m.GetIndicationMessageFormat2()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageValidationError{
						field:  "IndicationMessageFormat2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageValidationError{
						field:  "IndicationMessageFormat2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationMessageFormat2()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmIndicationMessageValidationError{
					field:  "IndicationMessageFormat2",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRsmIndicationMessageMultiError(errors)
	}

	return nil
}

// E2SmRsmIndicationMessageMultiError is an error wrapping multiple validation
// errors returned by E2SmRsmIndicationMessage.ValidateAll() if the designated
// constraints aren't met.
type E2SmRsmIndicationMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmIndicationMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmIndicationMessageMultiError) AllErrors() []error { return m }

// E2SmRsmIndicationMessageValidationError is the validation error returned by
// E2SmRsmIndicationMessage.Validate if the designated constraints aren't met.
type E2SmRsmIndicationMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmIndicationMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmIndicationMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmIndicationMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmIndicationMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmIndicationMessageValidationError) ErrorName() string {
	return "E2SmRsmIndicationMessageValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmIndicationMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmIndicationMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmIndicationMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmIndicationMessageValidationError{}

// Validate checks the field values on E2SmRsmIndicationMessageFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmIndicationMessageFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmIndicationMessageFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRsmIndicationMessageFormat1MultiError, or nil if none found.
func (m *E2SmRsmIndicationMessageFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmIndicationMessageFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRsmIndicationMessageFormat1ValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCuUeF1ApId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
					field:  "CuUeF1ApId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
					field:  "CuUeF1ApId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCuUeF1ApId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRsmIndicationMessageFormat1ValidationError{
				field:  "CuUeF1ApId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDuUeF1ApId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
					field:  "DuUeF1ApId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
					field:  "DuUeF1ApId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuUeF1ApId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRsmIndicationMessageFormat1ValidationError{
				field:  "DuUeF1ApId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EmmCase

	if l := len(m.GetUlSlicingMetrics()); l < 1 || l > 4294967295 {
		err := E2SmRsmIndicationMessageFormat1ValidationError{
			field:  "UlSlicingMetrics",
			reason: "value must contain between 1 and 4294967295 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetUlSlicingMetrics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
						field:  fmt.Sprintf("UlSlicingMetrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
						field:  fmt.Sprintf("UlSlicingMetrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmIndicationMessageFormat1ValidationError{
					field:  fmt.Sprintf("UlSlicingMetrics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if l := len(m.GetDlSlicingMetrics()); l < 1 || l > 4294967295 {
		err := E2SmRsmIndicationMessageFormat1ValidationError{
			field:  "DlSlicingMetrics",
			reason: "value must contain between 1 and 4294967295 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetDlSlicingMetrics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
						field:  fmt.Sprintf("DlSlicingMetrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageFormat1ValidationError{
						field:  fmt.Sprintf("DlSlicingMetrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmIndicationMessageFormat1ValidationError{
					field:  fmt.Sprintf("DlSlicingMetrics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRsmIndicationMessageFormat1MultiError(errors)
	}

	return nil
}

// E2SmRsmIndicationMessageFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmRsmIndicationMessageFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmRsmIndicationMessageFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmIndicationMessageFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmIndicationMessageFormat1MultiError) AllErrors() []error { return m }

// E2SmRsmIndicationMessageFormat1ValidationError is the validation error
// returned by E2SmRsmIndicationMessageFormat1.Validate if the designated
// constraints aren't met.
type E2SmRsmIndicationMessageFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmIndicationMessageFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmIndicationMessageFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmIndicationMessageFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmIndicationMessageFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmIndicationMessageFormat1ValidationError) ErrorName() string {
	return "E2SmRsmIndicationMessageFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmIndicationMessageFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmIndicationMessageFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmIndicationMessageFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmIndicationMessageFormat1ValidationError{}

// Validate checks the field values on E2SmRsmIndicationMessageFormat2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmIndicationMessageFormat2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmIndicationMessageFormat2 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRsmIndicationMessageFormat2MultiError, or nil if none found.
func (m *E2SmRsmIndicationMessageFormat2) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmIndicationMessageFormat2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TriggerType

	if l := len(m.GetUeIdlist()); l < 1 || l > 4 {
		err := E2SmRsmIndicationMessageFormat2ValidationError{
			field:  "UeIdlist",
			reason: "value must contain between 1 and 4 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetUeIdlist() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageFormat2ValidationError{
						field:  fmt.Sprintf("UeIdlist[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageFormat2ValidationError{
						field:  fmt.Sprintf("UeIdlist[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmIndicationMessageFormat2ValidationError{
					field:  fmt.Sprintf("UeIdlist[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PrefferedUeIdtype

	if len(m.GetBearerId()) > 32 {
		err := E2SmRsmIndicationMessageFormat2ValidationError{
			field:  "BearerId",
			reason: "value must contain no more than 32 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetBearerId() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageFormat2ValidationError{
						field:  fmt.Sprintf("BearerId[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmIndicationMessageFormat2ValidationError{
						field:  fmt.Sprintf("BearerId[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmIndicationMessageFormat2ValidationError{
					field:  fmt.Sprintf("BearerId[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRsmIndicationMessageFormat2MultiError(errors)
	}

	return nil
}

// E2SmRsmIndicationMessageFormat2MultiError is an error wrapping multiple
// validation errors returned by E2SmRsmIndicationMessageFormat2.ValidateAll()
// if the designated constraints aren't met.
type E2SmRsmIndicationMessageFormat2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmIndicationMessageFormat2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmIndicationMessageFormat2MultiError) AllErrors() []error { return m }

// E2SmRsmIndicationMessageFormat2ValidationError is the validation error
// returned by E2SmRsmIndicationMessageFormat2.Validate if the designated
// constraints aren't met.
type E2SmRsmIndicationMessageFormat2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmIndicationMessageFormat2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmIndicationMessageFormat2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmIndicationMessageFormat2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmIndicationMessageFormat2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmIndicationMessageFormat2ValidationError) ErrorName() string {
	return "E2SmRsmIndicationMessageFormat2ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmIndicationMessageFormat2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmIndicationMessageFormat2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmIndicationMessageFormat2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmIndicationMessageFormat2ValidationError{}

// Validate checks the field values on SliceParameters with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SliceParameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceParameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SliceParametersMultiError, or nil if none found.
func (m *SliceParameters) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceParameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SchedulerType

	if m.Weight != nil {
		// no validation rules for Weight
	}

	if m.QosLevel != nil {
		// no validation rules for QosLevel
	}

	if m.ScheduleInfo != nil {

		if all {
			switch v := interface{}(m.GetScheduleInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SliceParametersValidationError{
						field:  "ScheduleInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SliceParametersValidationError{
						field:  "ScheduleInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScheduleInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SliceParametersValidationError{
					field:  "ScheduleInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SliceParametersMultiError(errors)
	}

	return nil
}

// SliceParametersMultiError is an error wrapping multiple validation errors
// returned by SliceParameters.ValidateAll() if the designated constraints
// aren't met.
type SliceParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceParametersMultiError) AllErrors() []error { return m }

// SliceParametersValidationError is the validation error returned by
// SliceParameters.Validate if the designated constraints aren't met.
type SliceParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceParametersValidationError) ErrorName() string { return "SliceParametersValidationError" }

// Error satisfies the builtin error interface
func (e SliceParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceParameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceParametersValidationError{}

// Validate checks the field values on SliceConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SliceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SliceConfigMultiError, or
// nil if none found.
func (m *SliceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSliceId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SliceConfigValidationError{
					field:  "SliceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SliceConfigValidationError{
					field:  "SliceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSliceId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SliceConfigValidationError{
				field:  "SliceId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSliceConfigParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SliceConfigValidationError{
					field:  "SliceConfigParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SliceConfigValidationError{
					field:  "SliceConfigParameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSliceConfigParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SliceConfigValidationError{
				field:  "SliceConfigParameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SliceType

	if m.SliceDescription != nil {

		if l := utf8.RuneCountInString(m.GetSliceDescription()); l < 1 || l > 160 {
			err := SliceConfigValidationError{
				field:  "SliceDescription",
				reason: "value length must be between 1 and 160 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return SliceConfigMultiError(errors)
	}

	return nil
}

// SliceConfigMultiError is an error wrapping multiple validation errors
// returned by SliceConfig.ValidateAll() if the designated constraints aren't met.
type SliceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceConfigMultiError) AllErrors() []error { return m }

// SliceConfigValidationError is the validation error returned by
// SliceConfig.Validate if the designated constraints aren't met.
type SliceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceConfigValidationError) ErrorName() string { return "SliceConfigValidationError" }

// Error satisfies the builtin error interface
func (e SliceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceConfigValidationError{}

// Validate checks the field values on SliceDelete with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SliceDelete) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceDelete with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SliceDeleteMultiError, or
// nil if none found.
func (m *SliceDelete) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceDelete) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSliceId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SliceDeleteValidationError{
					field:  "SliceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SliceDeleteValidationError{
					field:  "SliceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSliceId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SliceDeleteValidationError{
				field:  "SliceId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SliceType

	if len(errors) > 0 {
		return SliceDeleteMultiError(errors)
	}

	return nil
}

// SliceDeleteMultiError is an error wrapping multiple validation errors
// returned by SliceDelete.ValidateAll() if the designated constraints aren't met.
type SliceDeleteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceDeleteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceDeleteMultiError) AllErrors() []error { return m }

// SliceDeleteValidationError is the validation error returned by
// SliceDelete.Validate if the designated constraints aren't met.
type SliceDeleteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceDeleteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceDeleteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceDeleteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceDeleteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceDeleteValidationError) ErrorName() string { return "SliceDeleteValidationError" }

// Error satisfies the builtin error interface
func (e SliceDeleteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceDelete.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceDeleteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceDeleteValidationError{}

// Validate checks the field values on SliceAssociate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SliceAssociate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliceAssociate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SliceAssociateMultiError,
// or nil if none found.
func (m *SliceAssociate) ValidateAll() error {
	return m.validate(true)
}

func (m *SliceAssociate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SliceAssociateValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SliceAssociateValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SliceAssociateValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetBearerId()); l < 1 || l > 32 {
		err := SliceAssociateValidationError{
			field:  "BearerId",
			reason: "value must contain between 1 and 32 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetBearerId() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SliceAssociateValidationError{
						field:  fmt.Sprintf("BearerId[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SliceAssociateValidationError{
						field:  fmt.Sprintf("BearerId[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SliceAssociateValidationError{
					field:  fmt.Sprintf("BearerId[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDownLinkSliceId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SliceAssociateValidationError{
					field:  "DownLinkSliceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SliceAssociateValidationError{
					field:  "DownLinkSliceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDownLinkSliceId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SliceAssociateValidationError{
				field:  "DownLinkSliceId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.UplinkSliceId != nil {

		if all {
			switch v := interface{}(m.GetUplinkSliceId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SliceAssociateValidationError{
						field:  "UplinkSliceId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SliceAssociateValidationError{
						field:  "UplinkSliceId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUplinkSliceId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SliceAssociateValidationError{
					field:  "UplinkSliceId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SliceAssociateMultiError(errors)
	}

	return nil
}

// SliceAssociateMultiError is an error wrapping multiple validation errors
// returned by SliceAssociate.ValidateAll() if the designated constraints
// aren't met.
type SliceAssociateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliceAssociateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliceAssociateMultiError) AllErrors() []error { return m }

// SliceAssociateValidationError is the validation error returned by
// SliceAssociate.Validate if the designated constraints aren't met.
type SliceAssociateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliceAssociateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliceAssociateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliceAssociateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliceAssociateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliceAssociateValidationError) ErrorName() string { return "SliceAssociateValidationError" }

// Error satisfies the builtin error interface
func (e SliceAssociateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliceAssociate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliceAssociateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliceAssociateValidationError{}

// Validate checks the field values on BearerId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BearerId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BearerId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BearerIdMultiError, or nil
// if none found.
func (m *BearerId) ValidateAll() error {
	return m.validate(true)
}

func (m *BearerId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.BearerId.(type) {

	case *BearerId_DrbId:

		if all {
			switch v := interface{}(m.GetDrbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BearerIdValidationError{
						field:  "DrbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BearerIdValidationError{
						field:  "DrbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDrbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BearerIdValidationError{
					field:  "DrbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BearerIdMultiError(errors)
	}

	return nil
}

// BearerIdMultiError is an error wrapping multiple validation errors returned
// by BearerId.ValidateAll() if the designated constraints aren't met.
type BearerIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BearerIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BearerIdMultiError) AllErrors() []error { return m }

// BearerIdValidationError is the validation error returned by
// BearerId.Validate if the designated constraints aren't met.
type BearerIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BearerIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BearerIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BearerIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BearerIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BearerIdValidationError) ErrorName() string { return "BearerIdValidationError" }

// Error satisfies the builtin error interface
func (e BearerIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBearerId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BearerIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BearerIdValidationError{}

// Validate checks the field values on DrbId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DrbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DrbId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DrbIdMultiError, or nil if none found.
func (m *DrbId) ValidateAll() error {
	return m.validate(true)
}

func (m *DrbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.DrbId.(type) {

	case *DrbId_FourGdrbId:

		if all {
			switch v := interface{}(m.GetFourGdrbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DrbIdValidationError{
						field:  "FourGdrbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DrbIdValidationError{
						field:  "FourGdrbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFourGdrbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DrbIdValidationError{
					field:  "FourGdrbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DrbId_FiveGdrbId:

		if all {
			switch v := interface{}(m.GetFiveGdrbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DrbIdValidationError{
						field:  "FiveGdrbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DrbIdValidationError{
						field:  "FiveGdrbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFiveGdrbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DrbIdValidationError{
					field:  "FiveGdrbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DrbIdMultiError(errors)
	}

	return nil
}

// DrbIdMultiError is an error wrapping multiple validation errors returned by
// DrbId.ValidateAll() if the designated constraints aren't met.
type DrbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DrbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DrbIdMultiError) AllErrors() []error { return m }

// DrbIdValidationError is the validation error returned by DrbId.Validate if
// the designated constraints aren't met.
type DrbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DrbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DrbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DrbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DrbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DrbIdValidationError) ErrorName() string { return "DrbIdValidationError" }

// Error satisfies the builtin error interface
func (e DrbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDrbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DrbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DrbIdValidationError{}

// Validate checks the field values on FiveGDrbId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FiveGDrbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FiveGDrbId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FiveGDrbIdMultiError, or
// nil if none found.
func (m *FiveGDrbId) ValidateAll() error {
	return m.validate(true)
}

func (m *FiveGDrbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if all {
		switch v := interface{}(m.GetQfi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FiveGDrbIdValidationError{
					field:  "Qfi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FiveGDrbIdValidationError{
					field:  "Qfi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQfi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FiveGDrbIdValidationError{
				field:  "Qfi",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetFlowsMapToDrb()); l < 1 || l > 64 {
		err := FiveGDrbIdValidationError{
			field:  "FlowsMapToDrb",
			reason: "value must contain between 1 and 64 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetFlowsMapToDrb() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FiveGDrbIdValidationError{
						field:  fmt.Sprintf("FlowsMapToDrb[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FiveGDrbIdValidationError{
						field:  fmt.Sprintf("FlowsMapToDrb[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FiveGDrbIdValidationError{
					field:  fmt.Sprintf("FlowsMapToDrb[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FiveGDrbIdMultiError(errors)
	}

	return nil
}

// FiveGDrbIdMultiError is an error wrapping multiple validation errors
// returned by FiveGDrbId.ValidateAll() if the designated constraints aren't met.
type FiveGDrbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FiveGDrbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FiveGDrbIdMultiError) AllErrors() []error { return m }

// FiveGDrbIdValidationError is the validation error returned by
// FiveGDrbId.Validate if the designated constraints aren't met.
type FiveGDrbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FiveGDrbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FiveGDrbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FiveGDrbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FiveGDrbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FiveGDrbIdValidationError) ErrorName() string { return "FiveGDrbIdValidationError" }

// Error satisfies the builtin error interface
func (e FiveGDrbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFiveGDrbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FiveGDrbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FiveGDrbIdValidationError{}

// Validate checks the field values on QoSflowLevelParameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QoSflowLevelParameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QoSflowLevelParameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QoSflowLevelParametersMultiError, or nil if none found.
func (m *QoSflowLevelParameters) ValidateAll() error {
	return m.validate(true)
}

func (m *QoSflowLevelParameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.QoSflowLevelParameters.(type) {

	case *QoSflowLevelParameters_DynamicFiveQi:

		if all {
			switch v := interface{}(m.GetDynamicFiveQi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QoSflowLevelParametersValidationError{
						field:  "DynamicFiveQi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QoSflowLevelParametersValidationError{
						field:  "DynamicFiveQi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDynamicFiveQi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QoSflowLevelParametersValidationError{
					field:  "DynamicFiveQi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QoSflowLevelParameters_NonDynamicFiveQi:

		if all {
			switch v := interface{}(m.GetNonDynamicFiveQi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QoSflowLevelParametersValidationError{
						field:  "NonDynamicFiveQi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QoSflowLevelParametersValidationError{
						field:  "NonDynamicFiveQi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNonDynamicFiveQi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QoSflowLevelParametersValidationError{
					field:  "NonDynamicFiveQi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QoSflowLevelParametersMultiError(errors)
	}

	return nil
}

// QoSflowLevelParametersMultiError is an error wrapping multiple validation
// errors returned by QoSflowLevelParameters.ValidateAll() if the designated
// constraints aren't met.
type QoSflowLevelParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QoSflowLevelParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QoSflowLevelParametersMultiError) AllErrors() []error { return m }

// QoSflowLevelParametersValidationError is the validation error returned by
// QoSflowLevelParameters.Validate if the designated constraints aren't met.
type QoSflowLevelParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QoSflowLevelParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QoSflowLevelParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QoSflowLevelParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QoSflowLevelParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QoSflowLevelParametersValidationError) ErrorName() string {
	return "QoSflowLevelParametersValidationError"
}

// Error satisfies the builtin error interface
func (e QoSflowLevelParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQoSflowLevelParameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QoSflowLevelParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QoSflowLevelParametersValidationError{}

// Validate checks the field values on DynamicFiveQi with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DynamicFiveQi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DynamicFiveQi with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DynamicFiveQiMultiError, or
// nil if none found.
func (m *DynamicFiveQi) ValidateAll() error {
	return m.validate(true)
}

func (m *DynamicFiveQi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PriorityLevel

	// no validation rules for PacketDelayBudget

	// no validation rules for PacketErrorRate

	if len(errors) > 0 {
		return DynamicFiveQiMultiError(errors)
	}

	return nil
}

// DynamicFiveQiMultiError is an error wrapping multiple validation errors
// returned by DynamicFiveQi.ValidateAll() if the designated constraints
// aren't met.
type DynamicFiveQiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DynamicFiveQiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DynamicFiveQiMultiError) AllErrors() []error { return m }

// DynamicFiveQiValidationError is the validation error returned by
// DynamicFiveQi.Validate if the designated constraints aren't met.
type DynamicFiveQiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DynamicFiveQiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DynamicFiveQiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DynamicFiveQiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DynamicFiveQiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DynamicFiveQiValidationError) ErrorName() string { return "DynamicFiveQiValidationError" }

// Error satisfies the builtin error interface
func (e DynamicFiveQiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDynamicFiveQi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DynamicFiveQiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DynamicFiveQiValidationError{}

// Validate checks the field values on NonDynamicFiveQi with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NonDynamicFiveQi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NonDynamicFiveQi with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NonDynamicFiveQiMultiError, or nil if none found.
func (m *NonDynamicFiveQi) ValidateAll() error {
	return m.validate(true)
}

func (m *NonDynamicFiveQi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFiveQi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NonDynamicFiveQiValidationError{
					field:  "FiveQi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NonDynamicFiveQiValidationError{
					field:  "FiveQi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFiveQi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NonDynamicFiveQiValidationError{
				field:  "FiveQi",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NonDynamicFiveQiMultiError(errors)
	}

	return nil
}

// NonDynamicFiveQiMultiError is an error wrapping multiple validation errors
// returned by NonDynamicFiveQi.ValidateAll() if the designated constraints
// aren't met.
type NonDynamicFiveQiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NonDynamicFiveQiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NonDynamicFiveQiMultiError) AllErrors() []error { return m }

// NonDynamicFiveQiValidationError is the validation error returned by
// NonDynamicFiveQi.Validate if the designated constraints aren't met.
type NonDynamicFiveQiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NonDynamicFiveQiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NonDynamicFiveQiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NonDynamicFiveQiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NonDynamicFiveQiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NonDynamicFiveQiValidationError) ErrorName() string { return "NonDynamicFiveQiValidationError" }

// Error satisfies the builtin error interface
func (e NonDynamicFiveQiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNonDynamicFiveQi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NonDynamicFiveQiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NonDynamicFiveQiValidationError{}

// Validate checks the field values on FourGDrbId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FourGDrbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FourGDrbId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FourGDrbIdMultiError, or
// nil if none found.
func (m *FourGDrbId) ValidateAll() error {
	return m.validate(true)
}

func (m *FourGDrbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if all {
		switch v := interface{}(m.GetQci()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FourGDrbIdValidationError{
					field:  "Qci",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FourGDrbIdValidationError{
					field:  "Qci",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQci()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FourGDrbIdValidationError{
				field:  "Qci",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FourGDrbIdMultiError(errors)
	}

	return nil
}

// FourGDrbIdMultiError is an error wrapping multiple validation errors
// returned by FourGDrbId.ValidateAll() if the designated constraints aren't met.
type FourGDrbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FourGDrbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FourGDrbIdMultiError) AllErrors() []error { return m }

// FourGDrbIdValidationError is the validation error returned by
// FourGDrbId.Validate if the designated constraints aren't met.
type FourGDrbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FourGDrbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FourGDrbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FourGDrbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FourGDrbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FourGDrbIdValidationError) ErrorName() string { return "FourGDrbIdValidationError" }

// Error satisfies the builtin error interface
func (e FourGDrbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFourGDrbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FourGDrbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FourGDrbIdValidationError{}

// Validate checks the field values on E2SmRsmRanfunctionDescription with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmRanfunctionDescription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmRanfunctionDescription with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRsmRanfunctionDescriptionMultiError, or nil if none found.
func (m *E2SmRsmRanfunctionDescription) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmRanfunctionDescription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRanFunctionName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRsmRanfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRsmRanfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRanFunctionName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRsmRanfunctionDescriptionValidationError{
				field:  "RanFunctionName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetRicSlicingNodeCapabilityList()); l < 1 || l > 4294967295 {
		err := E2SmRsmRanfunctionDescriptionValidationError{
			field:  "RicSlicingNodeCapabilityList",
			reason: "value must contain between 1 and 4294967295 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicSlicingNodeCapabilityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicSlicingNodeCapabilityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicSlicingNodeCapabilityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicSlicingNodeCapabilityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRsmRanfunctionDescriptionMultiError(errors)
	}

	return nil
}

// E2SmRsmRanfunctionDescriptionMultiError is an error wrapping multiple
// validation errors returned by E2SmRsmRanfunctionDescription.ValidateAll()
// if the designated constraints aren't met.
type E2SmRsmRanfunctionDescriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmRanfunctionDescriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmRanfunctionDescriptionMultiError) AllErrors() []error { return m }

// E2SmRsmRanfunctionDescriptionValidationError is the validation error
// returned by E2SmRsmRanfunctionDescription.Validate if the designated
// constraints aren't met.
type E2SmRsmRanfunctionDescriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmRanfunctionDescriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmRanfunctionDescriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmRanfunctionDescriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmRanfunctionDescriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmRanfunctionDescriptionValidationError) ErrorName() string {
	return "E2SmRsmRanfunctionDescriptionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmRanfunctionDescriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmRanfunctionDescription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmRanfunctionDescriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmRanfunctionDescriptionValidationError{}

// Validate checks the field values on E2SmRsmControlHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmControlHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmControlHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmRsmControlHeaderMultiError, or nil if none found.
func (m *E2SmRsmControlHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmControlHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RsmCommand

	if len(errors) > 0 {
		return E2SmRsmControlHeaderMultiError(errors)
	}

	return nil
}

// E2SmRsmControlHeaderMultiError is an error wrapping multiple validation
// errors returned by E2SmRsmControlHeader.ValidateAll() if the designated
// constraints aren't met.
type E2SmRsmControlHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmControlHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmControlHeaderMultiError) AllErrors() []error { return m }

// E2SmRsmControlHeaderValidationError is the validation error returned by
// E2SmRsmControlHeader.Validate if the designated constraints aren't met.
type E2SmRsmControlHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmControlHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmControlHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmControlHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmControlHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmControlHeaderValidationError) ErrorName() string {
	return "E2SmRsmControlHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmControlHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmControlHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmControlHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmControlHeaderValidationError{}

// Validate checks the field values on E2SmRsmControlMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRsmControlMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRsmControlMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmRsmControlMessageMultiError, or nil if none found.
func (m *E2SmRsmControlMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRsmControlMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmRsmControlMessage.(type) {

	case *E2SmRsmControlMessage_SliceCreate:

		if all {
			switch v := interface{}(m.GetSliceCreate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmControlMessageValidationError{
						field:  "SliceCreate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmControlMessageValidationError{
						field:  "SliceCreate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSliceCreate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmControlMessageValidationError{
					field:  "SliceCreate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *E2SmRsmControlMessage_SliceUpdate:

		if all {
			switch v := interface{}(m.GetSliceUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmControlMessageValidationError{
						field:  "SliceUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmControlMessageValidationError{
						field:  "SliceUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSliceUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmControlMessageValidationError{
					field:  "SliceUpdate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *E2SmRsmControlMessage_SliceDelete:

		if all {
			switch v := interface{}(m.GetSliceDelete()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmControlMessageValidationError{
						field:  "SliceDelete",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmControlMessageValidationError{
						field:  "SliceDelete",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSliceDelete()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmControlMessageValidationError{
					field:  "SliceDelete",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *E2SmRsmControlMessage_SliceAssociate:

		if all {
			switch v := interface{}(m.GetSliceAssociate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRsmControlMessageValidationError{
						field:  "SliceAssociate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRsmControlMessageValidationError{
						field:  "SliceAssociate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSliceAssociate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRsmControlMessageValidationError{
					field:  "SliceAssociate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRsmControlMessageMultiError(errors)
	}

	return nil
}

// E2SmRsmControlMessageMultiError is an error wrapping multiple validation
// errors returned by E2SmRsmControlMessage.ValidateAll() if the designated
// constraints aren't met.
type E2SmRsmControlMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRsmControlMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRsmControlMessageMultiError) AllErrors() []error { return m }

// E2SmRsmControlMessageValidationError is the validation error returned by
// E2SmRsmControlMessage.Validate if the designated constraints aren't met.
type E2SmRsmControlMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRsmControlMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRsmControlMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRsmControlMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRsmControlMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRsmControlMessageValidationError) ErrorName() string {
	return "E2SmRsmControlMessageValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRsmControlMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRsmControlMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRsmControlMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRsmControlMessageValidationError{}

// Validate checks the field values on ScheduleConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScheduleConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleConfigMultiError,
// or nil if none found.
func (m *ScheduleConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.LinkAdaptation != nil {

		if all {
			switch v := interface{}(m.GetLinkAdaptation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleConfigValidationError{
						field:  "LinkAdaptation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleConfigValidationError{
						field:  "LinkAdaptation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLinkAdaptation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleConfigValidationError{
					field:  "LinkAdaptation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Features != nil {

		if all {
			switch v := interface{}(m.GetFeatures()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleConfigValidationError{
						field:  "Features",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleConfigValidationError{
						field:  "Features",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFeatures()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleConfigValidationError{
					field:  "Features",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CarrierAggregationCap != nil {
		// no validation rules for CarrierAggregationCap
	}

	if m.UlPowerControl != nil {

		if all {
			switch v := interface{}(m.GetUlPowerControl()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleConfigValidationError{
						field:  "UlPowerControl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleConfigValidationError{
						field:  "UlPowerControl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUlPowerControl()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleConfigValidationError{
					field:  "UlPowerControl",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ScheduleConfigMultiError(errors)
	}

	return nil
}

// ScheduleConfigMultiError is an error wrapping multiple validation errors
// returned by ScheduleConfig.ValidateAll() if the designated constraints
// aren't met.
type ScheduleConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleConfigMultiError) AllErrors() []error { return m }

// ScheduleConfigValidationError is the validation error returned by
// ScheduleConfig.Validate if the designated constraints aren't met.
type ScheduleConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleConfigValidationError) ErrorName() string { return "ScheduleConfigValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleConfigValidationError{}

// Validate checks the field values on LinkAdaptation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LinkAdaptation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkAdaptation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LinkAdaptationMultiError,
// or nil if none found.
func (m *LinkAdaptation) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkAdaptation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.CqiCap != nil {
		// no validation rules for CqiCap
	}

	if m.RiCap != nil {
		// no validation rules for RiCap
	}

	if m.AggregationLevelCap != nil {
		// no validation rules for AggregationLevelCap
	}

	if m.TargetBlerDl != nil {
		// no validation rules for TargetBlerDl
	}

	if m.TargetBlerUl != nil {
		// no validation rules for TargetBlerUl
	}

	if m.MaxMcs != nil {
		// no validation rules for MaxMcs
	}

	if m.MinMcs != nil {
		// no validation rules for MinMcs
	}

	if m.TransmissionMode != nil {
		// no validation rules for TransmissionMode
	}

	if m.HarqRetxCap != nil {

		if all {
			switch v := interface{}(m.GetHarqRetxCap()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkAdaptationValidationError{
						field:  "HarqRetxCap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkAdaptationValidationError{
						field:  "HarqRetxCap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHarqRetxCap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkAdaptationValidationError{
					field:  "HarqRetxCap",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LinkAdaptationMultiError(errors)
	}

	return nil
}

// LinkAdaptationMultiError is an error wrapping multiple validation errors
// returned by LinkAdaptation.ValidateAll() if the designated constraints
// aren't met.
type LinkAdaptationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkAdaptationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkAdaptationMultiError) AllErrors() []error { return m }

// LinkAdaptationValidationError is the validation error returned by
// LinkAdaptation.Validate if the designated constraints aren't met.
type LinkAdaptationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkAdaptationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkAdaptationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkAdaptationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkAdaptationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkAdaptationValidationError) ErrorName() string { return "LinkAdaptationValidationError" }

// Error satisfies the builtin error interface
func (e LinkAdaptationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkAdaptation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkAdaptationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkAdaptationValidationError{}

// Validate checks the field values on HarqrextCap with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HarqrextCap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HarqrextCap with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HarqrextCapMultiError, or
// nil if none found.
func (m *HarqrextCap) ValidateAll() error {
	return m.validate(true)
}

func (m *HarqrextCap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Dl != nil {
		// no validation rules for Dl
	}

	if m.Ul != nil {
		// no validation rules for Ul
	}

	if len(errors) > 0 {
		return HarqrextCapMultiError(errors)
	}

	return nil
}

// HarqrextCapMultiError is an error wrapping multiple validation errors
// returned by HarqrextCap.ValidateAll() if the designated constraints aren't met.
type HarqrextCapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HarqrextCapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HarqrextCapMultiError) AllErrors() []error { return m }

// HarqrextCapValidationError is the validation error returned by
// HarqrextCap.Validate if the designated constraints aren't met.
type HarqrextCapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HarqrextCapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HarqrextCapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HarqrextCapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HarqrextCapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HarqrextCapValidationError) ErrorName() string { return "HarqrextCapValidationError" }

// Error satisfies the builtin error interface
func (e HarqrextCapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHarqrextCap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HarqrextCapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HarqrextCapValidationError{}

// Validate checks the field values on FeatureConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FeatureConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FeatureConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FeatureConfigMultiError, or
// nil if none found.
func (m *FeatureConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *FeatureConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TtiBundling != nil {
		// no validation rules for TtiBundling
	}

	if len(errors) > 0 {
		return FeatureConfigMultiError(errors)
	}

	return nil
}

// FeatureConfigMultiError is an error wrapping multiple validation errors
// returned by FeatureConfig.ValidateAll() if the designated constraints
// aren't met.
type FeatureConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FeatureConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FeatureConfigMultiError) AllErrors() []error { return m }

// FeatureConfigValidationError is the validation error returned by
// FeatureConfig.Validate if the designated constraints aren't met.
type FeatureConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FeatureConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FeatureConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FeatureConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FeatureConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FeatureConfigValidationError) ErrorName() string { return "FeatureConfigValidationError" }

// Error satisfies the builtin error interface
func (e FeatureConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFeatureConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FeatureConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FeatureConfigValidationError{}

// Validate checks the field values on UlpowerControl with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UlpowerControl) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UlpowerControl with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UlpowerControlMultiError,
// or nil if none found.
func (m *UlpowerControl) ValidateAll() error {
	return m.validate(true)
}

func (m *UlpowerControl) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PuschTargetSnr != nil {
		// no validation rules for PuschTargetSnr
	}

	if m.PucchTargetSnr != nil {
		// no validation rules for PucchTargetSnr
	}

	if len(errors) > 0 {
		return UlpowerControlMultiError(errors)
	}

	return nil
}

// UlpowerControlMultiError is an error wrapping multiple validation errors
// returned by UlpowerControl.ValidateAll() if the designated constraints
// aren't met.
type UlpowerControlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UlpowerControlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UlpowerControlMultiError) AllErrors() []error { return m }

// UlpowerControlValidationError is the validation error returned by
// UlpowerControl.Validate if the designated constraints aren't met.
type UlpowerControlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UlpowerControlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UlpowerControlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UlpowerControlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UlpowerControlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UlpowerControlValidationError) ErrorName() string { return "UlpowerControlValidationError" }

// Error satisfies the builtin error interface
func (e UlpowerControlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUlpowerControl.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UlpowerControlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UlpowerControlValidationError{}
