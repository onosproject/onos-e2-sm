// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: LicenseRef-ONF-Member-1.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"strings"
	"text/template"
	"unicode"
)

const moduleName = "cgo"

// Defines data structure to pass to template
type msgDataStruct struct {
	MessageName     string
	ProtoFileName   string
	PackageName     string
	FullPackageName string
	CstructName     string
	FieldList       fieldList
	Repeated        bool // Since there could be various combinations of such types
	OneOf           bool // We need to store all of them at the global level
	Optional        bool // each case should be handled by specific nested template
	//Dependencies  dependencies
}

//type dependencies struct {
//	Multiple         bool
//	DependenciesList []string
//}

type basicTypes struct {
	ProtoFileName   string
	PackageName     string
	FullPackageName string
}

// Defines data structure to pass to template
type fieldList struct {
	RepeatedField []elementaryField
	OneOfField    []elementaryField
	OptionalField []elementaryField
	SingleItem    bool
}

type elementaryField struct {
	MessageName     string
	ProtoFileName   string
	FieldName       string
	DataType        string
	FieldTypeName   string
	CstructName     string
	CstructLeafName string
}

// Defines data structure to pass to enum template
type enumDataStruct struct {
	MessageName     string
	ProtoFileName   string
	PackageName     string
	FullPackageName string
	CstructName     string
	FieldList       []elementaryField
}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// New configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}

	//TODO: Extract the SM version from the each function header. Some other values
	// could be also taken from function's header - format of parsing could be unified.
	// e.g. pass name of the .h file in the header, pass as [json_name] tag real name of the parameter in .h file.
	// As an example see EnbId, where I'm passing the same information via [json_name] tag -- this space could be reused.

	// ToDo: Discuss it with Sean

	// Missing types of structures to handle so far (TO BE UPDATED):
	// - Message with multiple Options inside --> implement with nested templates -- done
	// - OneOf structures -- done
	// - Repeated (generates lists) -- done
	// - Enums (missing valid C-names of leafs and proper decoding (match data type)) -- done
	// - doesn't support anonymous structs (yet) -- investigating in it --> harder than it seems to

	for _, f := range targets { // Input .proto files
		m.Push(f.Name().String()).Debug("reporting")

		basicTypesInfo := basicTypes{
			ProtoFileName:   extractProtoFileName(f.Name().Split()[0]),
			PackageName:     cleanDashes(underscoreToDash(cutE2SM(cutIES(extractProtoFileName(f.Name().Split()[0]))))),
			FullPackageName: adjustFullPackageName(f.Name().Split()[0]),
		}

		fmt.Fprintf(buf, "--- %v ---\n", f.Name().Split()[0])
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "------------------------------------------ Enums are -------------------------------------------\n")
		// ToDo: find a way how to pass comments to Enums -- [json_name] tag doesn't work
		for i, enum := range f.AllEnums() { // Constants
			fmt.Fprintf(buf, "%03d. Enum Name %v\n", i, enum.Name())
			fmt.Fprintf(buf, "%03d. Enum Descriptor %v\n", i, enum.Descriptor())
			enumData := enumDataStruct{
				MessageName:     enum.Name().String(),
				ProtoFileName:   basicTypesInfo.ProtoFileName,
				PackageName:     basicTypesInfo.PackageName,
				FullPackageName: basicTypesInfo.FullPackageName,
				CstructName:     "",
				FieldList:       make([]elementaryField, 0),
			}
			enumData.CstructName = extractEnumCstructName(enum.SourceCodeInfo().LeadingComments()) //.Name().String() // Don't know how to get it (yet)

			var listItem elementaryField

			for j, value := range enum.Descriptor().GetValue() {
				fmt.Fprintf(buf, "%03d. Enum Descriptor().GetValue().GetName() %v\n", j, value.GetName())
				fmt.Fprintf(buf, "%03d. Enum Descriptor().GetValue().GetNumber() %v\n", j, value.GetNumber())
				listItem.FieldName = value.GetName()
				listItem.ProtoFileName = basicTypesInfo.ProtoFileName
				listItem.MessageName = enum.Name().String()
				listItem.CstructLeafName = adjustEnumLeafName(squeezeDoubleDash(value.GetName()), enumData.CstructName) // Don't know how to obtain (yet)
				enumData.FieldList = append(enumData.FieldList, listItem)
			}

			tplEnum, err := template.New("enum.tpl").Funcs(template.FuncMap{
				"lowCaseFirstLetter":   lowCaseFirstLetter,
				"upperCaseFirstLetter": upperCaseFirstLetter,
				"dashToUnderscore":     dashToUnderscore,
				"underscoreToDash":     underscoreToDash,
				"tolow":                strings.ToLower,
				"cleanDashes":          cleanDashes,
				"cutIES":               cutIES,
			}).ParseFiles("enum.tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse template :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			if !findWithinBasicTypes(enumData.CstructName) {
				m.OverwriteGeneratorTemplateFile(underscoreToDash(enumData.CstructName)+".go", tplEnum, enumData)
			}

			//// Handling a unit test here
			//utTpl, err := template.New("unit_test.tpl").Funcs(template.FuncMap{
			//	"lowCaseFirstLetter":   lowCaseFirstLetter,
			//	"upperCaseFirstLetter": upperCaseFirstLetter,
			//	"dashToUnderscore":     dashToUnderscore,
			//	"underscoreToDash":     underscoreToDash,
			//	"tolow":                strings.ToLower,
			//	"cleanDashes":          cleanDashes,
			//	"cutIES":               cutIES,
			//}).ParseFiles("unit_test.tpl")
			//if err != nil {
			//	//fmt.Errorf("couldn't parse Unit Test template :/ %v", err)
			//	panic(err)
			//}
			//
			//// Generating new .go file
			//if !findWithinBasicTypes(enumData.CstructName) {
			//	m.OverwriteGeneratorTemplateFile(underscoreToDash(enumData.CstructName)+"_test.go", utTpl, enumData)
			//}
		}

		fmt.Fprintf(buf, "---------------------------------------- Messages are -----------------------------------------\n")
		for i, msg := range f.AllMessages() { // Messages in each of .proto files

			optional := false
			repeated := false
			oneof := false
			var cstructName string
			var items int = 0
			valueFound := false

			fieldItems := fieldList{
				RepeatedField: make([]elementaryField, 0),
				OneOfField:    make([]elementaryField, 0),
				OptionalField: make([]elementaryField, 0),
				SingleItem:    false,
			}
			//deps := dependencies{
			//	Multiple:         false,
			//	DependenciesList: make([]string, 0),
			//}

			flds := msg.Descriptor().GetField()
			fmt.Fprintf(buf, "%03d. Message Descriptor() %v\n", i, msg.Descriptor())
			fmt.Fprintf(buf, "%03d. Message Name() %v\n", i, extractProtoFileName(f.Name().Split()[0]))

			for _, fld := range flds {
				items++
				fmt.Fprintf(buf, "%03d. Field() -- %v\n ", i, fld.String())

				var elemField elementaryField

				elemField.FieldName = adjustFieldName(fld.GetName())
				elemField.CstructLeafName = dashToUnderscore(extractCstructFieldName(fld.GetJsonName()))
				if strings.Contains(strings.ToLower(elemField.FieldName), "value") {
					valueFound = true
				}

				cstructName = extractCstructName(fld.GetJsonName())
				elemField.CstructName = extractCstructName(fld.GetJsonName())

				elemField.DataType = convertDataType(extractDataType(fld.GetType().String()),
					extractDependentType(msg.Package().ProtoName().String(), fld.GetTypeName()))

				//deps.DependenciesList = putDependency(deps.DependenciesList, elemField.CstructName)

				elemField.MessageName = msg.Name().String()
				elemField.ProtoFileName = basicTypesInfo.ProtoFileName
				elemField.FieldTypeName = extractTypeName(msg.FullyQualifiedName(), msg.Package().ProtoName().String())
				//fmt.Fprintf(buf, "%03d. Message Descriptor().OneOfDecl() %v\n", i, msg.Descriptor().GetOneofDecl())

				if msg.Descriptor().GetOneofDecl() != nil {
					oneof = true
					fieldItems.OneOfField = append(fieldItems.OneOfField, elemField)
				} else {
					switch extractLabel(fld.GetLabel().String()) {
					case "OPTIONAL":
						optional = true
						fieldItems.OptionalField = append(fieldItems.OptionalField, elemField)

					case "REPEATED":
						repeated = true
						fieldItems.RepeatedField = append(fieldItems.RepeatedField, elemField)

					default: // If message has only one leaf it is still "OPTIONAL"
						optional = true
						fieldItems.OptionalField = append(fieldItems.OptionalField, elemField)

					}
				}
			}

			// ToDo - Go through the nested types
			//nstdTypes := msg.Descriptor().GetNestedType()
			// ...

			if items == 1 && valueFound {
				fieldItems.SingleItem = true
			}
			//if len(deps.DependenciesList) > 1 {
			//	deps.Multiple = true
			//}

			// Filling in data structure to pass to template with correct input
			msgData := msgDataStruct{
				MessageName:     msg.Name().String(),
				ProtoFileName:   basicTypesInfo.ProtoFileName,
				PackageName:     basicTypesInfo.PackageName,
				FullPackageName: basicTypesInfo.FullPackageName,
				CstructName:     cstructName,
				FieldList:       fieldItems,
				OneOf:           oneof,
				Repeated:        repeated,
				Optional:        optional,
				//Dependencies:  deps,
			}
			fmt.Fprintf(buf, "%03d. Gathered Message Data -- %v\n ", i, msgData)

			fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")

			tplMsg, err := template.New("message.tpl").Funcs(template.FuncMap{
				"lowCaseFirstLetter":   lowCaseFirstLetter,
				"upperCaseFirstLetter": upperCaseFirstLetter,
				"dashToUnderscore":     dashToUnderscore,
				"underscoreToDash":     underscoreToDash,
				"decodeDataType":       decodeDataType,
				"encodeDataType":       encodeDataType,
				"checkElementaryType":  checkElementaryType,
				"cleanDashes":          cleanDashes,
				"cutIES":               cutIES,
			}).ParseFiles("message.tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse Message template :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			if !findWithinBasicTypes(msgData.CstructName) {
				m.OverwriteGeneratorTemplateFile(underscoreToDash(msgData.CstructName)+".go", tplMsg, msgData)
			}

			// Handling a unit test
			utTpl, err := template.New("unit_test.tpl").Funcs(template.FuncMap{
				"lowCaseFirstLetter":   lowCaseFirstLetter,
				"upperCaseFirstLetter": upperCaseFirstLetter,
				"dashToUnderscore":     dashToUnderscore,
				"underscoreToDash":     underscoreToDash,
				"decodeDataType":       decodeDataType,
				"encodeDataType":       encodeDataType,
				"checkElementaryType":  checkElementaryType,
				"cleanDashes":          cleanDashes,
				"cutIES":               cutIES,
			}).ParseFiles("unit_test.tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse Unit Test template :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			if !findWithinBasicTypes(msgData.CstructName) {
				m.OverwriteGeneratorTemplateFile(underscoreToDash(msgData.CstructName)+"_test.go", utTpl, msgData)
			}

			// Handling a type creation
			typesTpl, err := template.New("types_gen.tpl").Funcs(template.FuncMap{
				"lowCaseFirstLetter":   lowCaseFirstLetter,
				"upperCaseFirstLetter": upperCaseFirstLetter,
				"dashToUnderscore":     dashToUnderscore,
				"underscoreToDash":     underscoreToDash,
				"decodeDataType":       decodeDataType,
				"encodeDataType":       encodeDataType,
				"checkElementaryType":  checkElementaryType,
				"cleanDashes":          cleanDashes,
				"cutIES":               cutIES,
			}).ParseFiles("types_gen.tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse template for types generation :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			if !findWithinBasicTypes(msgData.CstructName) {
				m.OverwriteGeneratorTemplateFile(underscoreToDash(msgData.MessageName)+".go", typesTpl, msgData)
			}
		}

		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "---------------------------------------- Dependents are -----------------------------------------\n")
		for i, dep := range f.Dependents() { // God knows what it is
			fmt.Fprintf(buf, "%03d. %v\n ", i, dep.Dependents())
		}

		m.Pop()
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")

		// TODO: Cleaning up generated code - investigate later on
		//rc, wc, _ := pipe.Commands(
		//	exec.Command("gofmt"),
		//	exec.Command("goimports"),
		//)
		//t.Execute(wc, d)
		//wc.Close()
		//io.Copy(os.Stdout, rc)

		// Printing basic types
		basicTypesList := getBasicTypes()
		for _, item := range basicTypesList {
			basicTpl, err := template.New(item + ".tpl").Funcs(template.FuncMap{
				"dashToUnderscore": dashToUnderscore,
				"underscoreToDash": underscoreToDash,
				"cutIES":           cutIES,
			}).ParseFiles(item + ".tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse template :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			m.OverwriteGeneratorTemplateFile(item+".go", basicTpl, basicTypesInfo)
		}

	}
	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)

	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func lowCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToLower(ch)) + str[i+1:]
	}
	return ""
}

func upperCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToUpper(ch)) + str[i+1:]
	}
	return ""
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}

func underscoreToDash(str string) string {

	return strings.ReplaceAll(str, "_", "-")
}

func extractTypeName(fullStr string, delStr string) string {

	return strings.ReplaceAll(fullStr, "."+delStr+".", "")
}

func extractCstructName(str string) string {

	if !strings.Contains(str, ":") {
		return str
	}
	return str[:strings.Index(str, ":")]
}

func extractCstructFieldName(str string) string {

	if !strings.Contains(str, ":") {
		return ""
	}
	return str[strings.Index(str, ":")+1:]
}

func squeezeDoubleDash(str string) string {

	return strings.ReplaceAll(str, "__", "_")
}

func cleanDashes(str string) string {

	return strings.ReplaceAll(str, "-", "")
}

func extractDataType(str string) string {

	return strings.ToLower(strings.ReplaceAll(str, "TYPE_", ""))
}

func cutIES(str string) string {

	return strings.ToLower(strings.ReplaceAll(str, "_ies", ""))
}

func cutE2SM(str string) string {

	return strings.ToLower(strings.ReplaceAll(str, "e2sm_", ""))
}

func extractLabel(str string) string {

	return strings.ReplaceAll(str, "LABEL_", "")
}

func extractDependentType(messageProtoName string, typeName string) string {

	return strings.ReplaceAll(typeName, "."+messageProtoName+".", "")
}

func convertDataType(str string, dependentEncoder string) string {

	switch str {
	case "int32", "uint32", "uint64":
		return str
	case "bytes":
		return "[]byte"
	case "message", "enum":
		return dependentEncoder
	default:
		return upperCaseFirstLetter(str)
	}
}

func decodeDataType(dataType string) string {

	switch strings.ToLower(dataType) {
	case "int32", "uint32", "uint64":
		return dataType
	case "[]byte": // ToDo - sometimes could be OctetString
		return dataType
	case "string":
		return "decodePrintableString"
	case "int64":
		return "decodeInteger"
	case "message": //ToDo: isn't it pointless?? -- missing enum then
		return "decode" + upperCaseFirstLetter(dataType)
	default:
		return "decode" + upperCaseFirstLetter(dataType)
	}
}

func encodeDataType(dataType string) string {

	switch strings.ToLower(dataType) {
	case "int32", "uint32", "uint64":
		return "C.long"
	case "[]byte": // ToDo - sometimes could be OctetString
		return dataType
	case "string":
		return "decodePrintableString"
	case "int64":
		return "newInteger"
	case "message": //ToDo: isn't it pointless?? -- missing enum then
		return "new" + upperCaseFirstLetter(dataType)
	default:
		return "new" + upperCaseFirstLetter(dataType)
	}
}

func checkElementaryType(dataType string) bool {

	switch dataType {
	case "int32", "uint32", "uint64", "[]byte":
		return true
	default:
		return false
	}
}

func adjustFieldName(fieldName string) string {

	res := ""

	array := strings.Split(fieldName, "_")
	for _, item := range array {
		res = res + upperCaseFirstLetter(item)
	}

	return upperCaseFirstLetter(res)
}

func adjustEnumLeafName(leafName string, msgName string) string {

	return upperCaseFirstLetter(dashToUnderscore(msgName) +
		strings.ReplaceAll(strings.ToLower(leafName), strings.ToLower(dashToUnderscore(dashToUnderscore(msgName))), ""))
}

func adjustFullPackageName(fullPackageName string) string {
	path := strings.ReplaceAll(fullPackageName, extractProtoFileName(fullPackageName), "")
	adjustedPackageName := underscoreToDash(extractProtoFileName(fullPackageName))
	return path + adjustedPackageName
}

func extractEnumCstructName(name string) string {

	return name[strings.Index(name, "{")+1 : strings.Index(name, "}")]
}

func extractProtoFileName(proto string) string {

	if strings.LastIndex(proto, "/") != 1 {
		return proto[strings.LastIndex(proto, "/")+1:]
	}
	return proto
}

//func putDependency(list []string, dependency string) []string {
//
//	match := false
//	for _, item := range list {
//		if strings.EqualFold(item, dependency) {
//			match = true
//		}
//	}
//	if !match {
//		list = append(list, dependency)
//	}
//
//	return list
//}

func getBasicTypes() []string {
	return []string{"asn_codecs_prim", "BIT_STRING", "INTEGER", "OCTET_STRING", "PrintableString", "BOOLEAN"}
}

func findWithinBasicTypes(fileName string) bool {

	for _, item := range getBasicTypes() {
		if strings.EqualFold(strings.ToLower(underscoreToDash(fileName)), strings.ToLower(underscoreToDash(item))) {
			return true
		}
	}

	return false
}

//ToDo - implement proper linting..
//func lintingInstance(str string) string {
//
//	strings.ReplaceAll(str, "Id", "ID")
//	strings.ReplaceAll(str, "id", "ID")
//
//	return str
//}
