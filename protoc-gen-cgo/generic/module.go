// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: LicenseRef-ONF-Member-1.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"strings"
	"text/template"
	"unicode"
)

const moduleName = "cgo"

// Defines data structure to pass to template
type msgDataStruct struct {
	MessageName     string
	GlobalName      string
	ProtoFileName   string
	PackageName     string
	FullPackageName string
	CstructName     string
	FieldList       fieldList
	Repeated        bool // Since there could be various combinations of such types
	OneOf           bool // We need to store all of them at the global level
	Optional        bool // each case should be handled by specific nested template
	//Dependencies  dependencies
}

//type dependencies struct {
//	Multiple         bool
//	DependenciesList []string
//}

type basicTypes struct {
	ProtoFileName   string
	PackageName     string
	FullPackageName string
}

// Defines data structure to pass to template
type fieldList struct {
	RepeatedField []elementaryField
	OneOfField    []elementaryField
	OptionalField []elementaryField
	SingleItem    bool
}

type elementaryField struct {
	MessageName     string
	GlobalName      string
	ProtoFileName   string
	FieldName       string
	DataType        string
	FieldTypeName   string
	CstructName     string
	CstructLeafName string
	Optionality     bool // This item identifies whether structure is OPTIONAL in ASN1 definition
	VariableName    string
}

// Defines data structure to pass to enum template
type enumDataStruct struct {
	MessageName     string
	GlobalName      string
	ProtoFileName   string
	PackageName     string
	FullPackageName string
	CstructName     string
	FieldList       []elementaryField
}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// NewModule configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}
	//fmt.Printf("Parameters are \n%v", m.Parameters().String())

	//TODO: Extract the SM version from the each function header. Some other values
	// could be also taken from function's header - format of parsing could be unified.
	// e.g. pass name of the .h file in the header, pass as [json_name] tag real name of the parameter in .h file.
	// As an example see EnbId, where I'm passing the same information via [json_name] tag -- this space could be reused.

	// ToDo: Discuss it with Sean

	// Missing types of structures to handle so far (TO BE UPDATED):
	// - Message with multiple Options inside --> implement with nested templates -- done
	// - OneOf structures -- done
	// - Repeated (generates lists) -- done
	// - Enums (missing valid C-names of leafs and proper decoding (match data type)) -- done
	// - doesn't support anonymous structs (yet) -- investigating in it --> harder than it seems to

	for _, f := range targets { // Input .proto files
		m.Push(f.Name().String()).Debug("reporting")

		basicTypesInfo := basicTypes{
			ProtoFileName:   extractProtoFileName(f.Name().Split()[0]),
			PackageName:     cleanDashes(underscoreToDash(cutE2SM(cutIES(extractProtoFileName(f.Name().Split()[0]))))),
			FullPackageName: adjustFullPackageName(f.Name().Split()[0]),
		}

		fmt.Fprintf(buf, "--- %v ---\n", f.Name().Split()[0])
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "------------------------------------------ Enums are -------------------------------------------\n")
		// ToDo: find a way how to pass comments to Enums -- [json_name] tag doesn't work
		for i, enum := range f.AllEnums() { // Constants

			// If it's not a constant (or any other message which doesn't have specific C-structs - process and create a file, otherwise ignore
			if !strings.Contains(enum.SourceCodeInfo().LeadingComments(), "{-}") &&
				!strings.Contains(enum.SourceCodeInfo().LeadingComments(), "constant") {
				fmt.Fprintf(buf, "%03d. Enum Name %v\n", i, enum.Name())
				fmt.Fprintf(buf, "%03d. Enum Descriptor %v\n", i, enum.Descriptor())
				enumData := enumDataStruct{
					MessageName:     enum.Name().String(),
					GlobalName:      doLinting(enum.Name().String()),
					ProtoFileName:   basicTypesInfo.ProtoFileName,
					PackageName:     basicTypesInfo.PackageName,
					FullPackageName: basicTypesInfo.FullPackageName,
					CstructName:     "",
					FieldList:       make([]elementaryField, 0),
				}
				enumData.CstructName = extractCstructName(enum.SourceCodeInfo().LeadingComments()) //.Name().String() // Don't know how to get it (yet)

				var listItem elementaryField

				for j, value := range enum.Descriptor().GetValue() {
					fmt.Fprintf(buf, "%03d. Enum Descriptor().GetValue().GetName() %v\n", j, value.GetName())
					fmt.Fprintf(buf, "%03d. Enum Descriptor().GetValue().GetNumber() %v\n", j, value.GetNumber())
					listItem.FieldName = lowCaseFirstLetter(value.GetName())
					listItem.ProtoFileName = basicTypesInfo.ProtoFileName
					listItem.MessageName = enum.Name().String()
					listItem.VariableName = doLinting(enum.Name().String())
					listItem.CstructLeafName = adjustEnumLeafName(squeezeDoubleDash(value.GetName()), enumData.CstructName) // Don't know how to obtain (yet)
					enumData.FieldList = append(enumData.FieldList, listItem)
				}

				tplEnum, err := template.New("enum.tpl").Funcs(template.FuncMap{
					"lowCaseFirstLetter":   lowCaseFirstLetter,
					"upperCaseFirstLetter": upperCaseFirstLetter,
					"dashToUnderscore":     dashToUnderscore,
					"underscoreToDash":     underscoreToDash,
					"tolow":                strings.ToLower,
					"cleanDashes":          cleanDashes,
					"cutIES":               cutIES,
				}).ParseFiles("enum.tpl")
				if err != nil {
					//fmt.Errorf("couldn't parse template :/ %v", err)
					panic(err)
				}

				param, _ := m.Parameters().Bool("cgo")
				//if err != nil {
				//	fmt.Errorf("parameter cgo wasn't found in the set %v", err)
				//}

				// Generating new .go file
				if !findWithinBasicTypes(enumData.CstructName) && param {
					m.OverwriteGeneratorTemplateFile(underscoreToDash(enumData.CstructName)+".go", tplEnum, enumData)
				}

				//// Handling a unit test here
				//utTpl, err := template.New("unit_test.tpl").Funcs(template.FuncMap{
				//	"lowCaseFirstLetter":   lowCaseFirstLetter,
				//	"upperCaseFirstLetter": upperCaseFirstLetter,
				//	"dashToUnderscore":     dashToUnderscore,
				//	"underscoreToDash":     underscoreToDash,
				//	"tolow":                strings.ToLower,
				//	"cleanDashes":          cleanDashes,
				//	"cutIES":               cutIES,
				//}).ParseFiles("unit_test.tpl")
				//if err != nil {
				//	//fmt.Errorf("couldn't parse Unit Test template :/ %v", err)
				//	panic(err)
				//}
				//
				//// Generating new .go file
				//if !findWithinBasicTypes(enumData.CstructName) {
				//	m.OverwriteGeneratorTemplateFile(underscoreToDash(enumData.CstructName)+"_test.go", utTpl, enumData)
				//}
			}
		}

		fmt.Fprintf(buf, "---------------------------------------- Messages are -----------------------------------------\n")
		for i, msg := range f.AllMessages() { // Messages in each of .proto files

			// If it's not a constant (or any other message which doesn't have specific C-structs - process and create a file, otherwise ignore
			if !strings.Contains(msg.SourceCodeInfo().LeadingComments(), "{-}") &&
				!strings.Contains(msg.SourceCodeInfo().LeadingComments(), "constant") {
				optional := false
				repeated := false
				oneof := false
				var cstructName string
				var items int = 0
				valueFound := false

				fieldItems := fieldList{
					RepeatedField: make([]elementaryField, 0),
					OneOfField:    make([]elementaryField, 0),
					OptionalField: make([]elementaryField, 0),
					SingleItem:    false,
				}
				//deps := dependencies{
				//	Multiple:         false,
				//	DependenciesList: make([]string, 0),
				//}

				flds := msg.Descriptor().GetField()
				fmt.Fprintf(buf, "%03d. Message Descriptor() %v\n", i, msg.Descriptor())
				fmt.Fprintf(buf, "%03d. Message Name() %v\n", i, extractProtoFileName(f.Name().Split()[0]))

				for _, fld := range flds {
					items++
					fmt.Fprintf(buf, "%03d. Field() -- %v\n ", i, fld.String())

					var elemField elementaryField

					elemField.FieldName = lowCaseFirstLetter(adjustFieldName(fld.GetName()))
					elemField.CstructLeafName = dashToUnderscore(extractCstructFieldName(fld.GetJsonName()))
					if strings.Contains(strings.ToLower(elemField.FieldName), "value") {
						valueFound = true
					}

					cstructName = extractCstructName(msg.SourceCodeInfo().LeadingComments())
					elemField.CstructName = cstructName
					elemField.Optionality = checkOptionalField(fld.GetJsonName())
					//elemField.VariableName = lowCaseFirstLetter(doLinting(msg.Name().String()))

					elemField.DataType = convertDataType(extractDataType(fld.GetType().String()),
						extractDependentType(msg.Package().ProtoName().String(), fld.GetTypeName()))

					//deps.DependenciesList = putDependency(deps.DependenciesList, elemField.CstructName)

					elemField.MessageName = msg.Name().String()
					elemField.VariableName = doLinting(msg.Name().String())
					elemField.GlobalName = elemField.VariableName
					elemField.ProtoFileName = basicTypesInfo.ProtoFileName
					elemField.FieldTypeName = extractTypeName(msg.FullyQualifiedName(), msg.Package().ProtoName().String())
					//fmt.Fprintf(buf, "%03d. Message Descriptor().OneOfDecl() %v\n", i, msg.Descriptor().GetOneofDecl())

					if msg.Descriptor().GetOneofDecl() != nil {
						oneof = true
						fieldItems.OneOfField = append(fieldItems.OneOfField, elemField)
					} else {
						switch extractLabel(fld.GetLabel().String()) {
						case "OPTIONAL":
							optional = true
							fieldItems.OptionalField = append(fieldItems.OptionalField, elemField)

						case "REPEATED":
							repeated = true
							fieldItems.RepeatedField = append(fieldItems.RepeatedField, elemField)

						default: // If message has only one leaf it is still "OPTIONAL"
							optional = true
							fieldItems.OptionalField = append(fieldItems.OptionalField, elemField)

						}
					}
				}

				// ToDo - Go through the nested types
				//nstdTypes := msg.Descriptor().GetNestedType()
				// ...

				if items == 1 && valueFound {
					fieldItems.SingleItem = true
				}
				//if len(deps.DependenciesList) > 1 {
				//	deps.Multiple = true
				//}

				// Filling in data structure to pass to template with correct input
				msgData := msgDataStruct{
					MessageName:     msg.Name().String(),
					GlobalName:      doLinting(msg.Name().String()),
					ProtoFileName:   basicTypesInfo.ProtoFileName,
					PackageName:     basicTypesInfo.PackageName,
					FullPackageName: basicTypesInfo.FullPackageName,
					CstructName:     cstructName,
					FieldList:       fieldItems,
					OneOf:           oneof,
					Repeated:        repeated,
					Optional:        optional,
					//VariableName: doLinting(msg.Name().String()), //ToDo - complete integration of linters
					//Dependencies:  deps,
				}
				fmt.Fprintf(buf, "%03d. Gathered Message Data -- %v\n ", i, msgData)

				fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")

				tplMsg, err := template.New("message.tpl").Funcs(template.FuncMap{
					"lowCaseFirstLetter":   lowCaseFirstLetter,
					"upperCaseFirstLetter": upperCaseFirstLetter,
					"dashToUnderscore":     dashToUnderscore,
					"underscoreToDash":     underscoreToDash,
					"decodeDataType":       decodeDataType,
					"encodeDataType":       encodeDataType,
					"checkElementaryType":  checkElementaryType,
					"cleanDashes":          cleanDashes,
					"cutIES":               cutIES,
					"doLinting":            doLinting,
				}).ParseFiles("message.tpl")
				if err != nil {
					//fmt.Errorf("couldn't parse Message template :/ %v", err)
					panic(err)
				}

				cgo, _ := m.Parameters().Bool("cgo")
				//if err != nil {
				//	fmt.Errorf("parameter cgo wasn't found in the input set %v", err)
				//}

				// Generating new .go file
				if !findWithinBasicTypes(msgData.CstructName) && cgo {
					m.OverwriteGeneratorTemplateFile(underscoreToDash(msgData.CstructName)+".go", tplMsg, msgData)
				}

				// Handling a unit test
				utTpl, err := template.New("unit_test.tpl").Funcs(template.FuncMap{
					"lowCaseFirstLetter":   lowCaseFirstLetter,
					"upperCaseFirstLetter": upperCaseFirstLetter,
					"dashToUnderscore":     dashToUnderscore,
					"underscoreToDash":     underscoreToDash,
					"decodeDataType":       decodeDataType,
					"encodeDataType":       encodeDataType,
					"checkElementaryType":  checkElementaryType,
					"cleanDashes":          cleanDashes,
					"cutIES":               cutIES,
					"doLinting":            doLinting,
				}).ParseFiles("unit_test.tpl")
				if err != nil {
					//fmt.Errorf("couldn't parse Unit Test template :/ %v", err)
					panic(err)
				}

				ut, _ := m.Parameters().Bool("ut")
				//if err != nil {
				//	fmt.Errorf("parameter ut wasn't found in the input set %v", err)
				//}

				// Generating new .go file
				if !findWithinBasicTypes(msgData.CstructName) && ut {
					m.OverwriteGeneratorTemplateFile(underscoreToDash(msgData.CstructName)+"_test.go", utTpl, msgData)
				}

				// Handling a type creation
				typesTpl, err := template.New("types_gen.tpl").Funcs(template.FuncMap{
					"lowCaseFirstLetter":   lowCaseFirstLetter,
					"upperCaseFirstLetter": upperCaseFirstLetter,
					"dashToUnderscore":     dashToUnderscore,
					"underscoreToDash":     underscoreToDash,
					"decodeDataType":       decodeDataType,
					"encodeDataType":       encodeDataType,
					"checkElementaryType":  checkElementaryType,
					"cleanDashes":          cleanDashes,
					"cutIES":               cutIES,
					"doLinting":            doLinting,
				}).ParseFiles("types_gen.tpl")
				if err != nil {
					//fmt.Errorf("couldn't parse template for types generation :/ %v", err)
					panic(err)
				}

				t, _ := m.Parameters().Bool("t")
				//if err != nil {
				//	fmt.Errorf("parameter t wasn't found in the input set %v", err)
				//}

				// Generating new .go file
				if !findWithinBasicTypes(msgData.CstructName) && t {
					m.OverwriteGeneratorTemplateFile(underscoreToDash(msgData.MessageName)+"_types.go", typesTpl, msgData)
				}
			}
		}

		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "---------------------------------------- Dependents are -----------------------------------------\n")
		for i, dep := range f.Dependents() { // God knows what it is
			fmt.Fprintf(buf, "%03d. %v\n ", i, dep.Dependents())
		}

		m.Pop()
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")

		// TODO: Cleaning up generated code - investigate later on
		//rc, wc, _ := pipe.Commands(
		//	exec.Command("gofmt"),
		//	exec.Command("goimports"),
		//)
		//t.Execute(wc, d)
		//wc.Close()
		//io.Copy(os.Stdout, rc)

		cgo, _ := m.Parameters().Bool("cgo")
		//if err != nil {
		//	fmt.Errorf("parameter cgo wasn't found in the input set %v", err)
		//}

		// Printing basic types
		if cgo {
			basicTypesList := getBasicTypes()
			for _, item := range basicTypesList {
				basicTpl, err := template.New(item + ".tpl").Funcs(template.FuncMap{
					"dashToUnderscore": dashToUnderscore,
					"underscoreToDash": underscoreToDash,
					"cutIES":           cutIES,
				}).ParseFiles(item + ".tpl")
				if err != nil {
					//fmt.Errorf("couldn't parse template :/ %v", err)
					panic(err)
				}

				// Generating new .go file
				m.OverwriteGeneratorTemplateFile(item+".go", basicTpl, basicTypesInfo)
			}
		}

	}
	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)

	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func lowCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToLower(ch)) + str[i+1:]
	}
	return ""
}

func upperCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToUpper(ch)) + str[i+1:]
	}
	return ""
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}

func underscoreToDash(str string) string {

	return strings.ReplaceAll(str, "_", "-")
}

func extractTypeName(fullStr string, delStr string) string {

	return strings.ReplaceAll(fullStr, "."+delStr+".", "")
}

func checkOptionalField(str string) bool {

	return strings.Contains(str, ":OPTIONAL")
}

func extractCstructFieldName(str string) string {

	if !strings.Contains(str, ":") {
		return str
	}
	return str[:strings.Index(str, ":")]
}

func squeezeDoubleDash(str string) string {

	return strings.ReplaceAll(str, "__", "_")
}

func cleanDashes(str string) string {

	return strings.ReplaceAll(str, "-", "")
}

func extractDataType(str string) string {

	return strings.ToLower(strings.ReplaceAll(str, "TYPE_", ""))
}

func cutIES(str string) string {

	return strings.ToLower(strings.ReplaceAll(str, "_ies", ""))
}

func cutE2SM(str string) string {

	return strings.ToLower(strings.ReplaceAll(str, "e2sm_", ""))
}

func extractLabel(str string) string {

	return strings.ReplaceAll(str, "LABEL_", "")
}

func extractDependentType(messageProtoName string, typeName string) string {

	return strings.ReplaceAll(typeName, "."+messageProtoName+".", "")
}

func convertDataType(str string, dependentEncoder string) string {

	switch str {
	case "int32", "uint32", "uint64":
		return str
	case "bytes":
		return "[]byte"
	case "message", "enum":
		return dependentEncoder
	default:
		return upperCaseFirstLetter(str)
	}
}

func decodeDataType(dataType string) string {

	switch strings.ToLower(dataType) {
	case "int32", "uint32", "uint64":
		return dataType
	case "[]byte": // ToDo - sometimes could be OctetString
		return "newOctetString"
	case "string":
		return "decodePrintableString"
	case "bool":
		return "decodeBoolean"
	case "int64":
		return "decodeInteger"
	case "message": //ToDo: isn't it pointless?? -- missing enum then
		return "decode" + upperCaseFirstLetter(doLinting(dataType))
	default:
		return "decode" + upperCaseFirstLetter(doLinting(dataType))
	}
}

func encodeDataType(dataType string) string {

	switch strings.ToLower(dataType) {
	case "int32", "uint32", "uint64":
		return "C.long"
	case "[]byte": // ToDo - sometimes could be OctetString
		return "decodeOctetString"
	case "string":
		return "newPrintableString"
	case "bool":
		return "newBoolean"
	case "int64":
		return "newInteger"
	case "message": //ToDo: isn't it pointless?? -- missing enum then
		return "new" + upperCaseFirstLetter(doLinting(dataType))
	default:
		return "new" + upperCaseFirstLetter(doLinting(dataType))
	}
}

func checkElementaryType(dataType string) bool {

	switch dataType {
	case "int32", "uint32", "uint64", "[]byte":
		return true
	default:
		return false
	}
}

func adjustFieldName(fieldName string) string {

	res := ""

	array := strings.Split(fieldName, "_")
	for _, item := range array {
		res = res + upperCaseFirstLetter(item)
	}

	return upperCaseFirstLetter(res)
}

func adjustEnumLeafName(leafName string, msgName string) string {

	return upperCaseFirstLetter(dashToUnderscore(msgName) +
		strings.ReplaceAll(strings.ToLower(leafName), strings.ToLower(dashToUnderscore(dashToUnderscore(msgName))), ""))
}

func adjustFullPackageName(fullPackageName string) string {
	path := strings.ReplaceAll(fullPackageName, extractProtoFileName(fullPackageName), "")
	adjustedPackageName := underscoreToDash(extractProtoFileName(fullPackageName))
	return path + adjustedPackageName
}

func extractCstructName(name string) string {

	return name[strings.Index(name, "{")+1 : strings.Index(name, "}")]
}

func extractProtoFileName(proto string) string {

	if strings.LastIndex(proto, "/") != 1 {
		return proto[strings.LastIndex(proto, "/")+1:]
	}
	return proto
}

//func putDependency(list []string, dependency string) []string {
//
//	match := false
//	for _, item := range list {
//		if strings.EqualFold(item, dependency) {
//			match = true
//		}
//	}
//	if !match {
//		list = append(list, dependency)
//	}
//
//	return list
//}

func getBasicTypes() []string {
	return []string{"asn_codecs_prim", "BIT_STRING", "INTEGER", "OCTET_STRING", "PrintableString", "BOOLEAN"}
}

func findWithinBasicTypes(fileName string) bool {

	for _, item := range getBasicTypes() {
		if strings.EqualFold(strings.ToLower(underscoreToDash(fileName)), strings.ToLower(underscoreToDash(item))) {
			return true
		}
	}

	return false
}

//ToDo - fix linting properly - overlapping with custom types for some reason..
func doLinting(str string) string {

	//Firstly verify if this instance should be linted - go through exceptions
	if strings.Contains(str, "PlmnIdentity") {
		return str
	}
	if strings.Contains(str, "Oid") {
		return str
	}
	if strings.Contains(str, "UeIdentity") {
		return str
	}

	res := strings.ReplaceAll(str, "Id", "ID")
	res = strings.ReplaceAll(res, "id", "ID")

	return res
}
