// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: LicenseRef-ONF-Member-1.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"strings"
	"text/template"
	"unicode"
)

const moduleName = "cgo"

// Defines data structure to pass to template
type msgDataStruct struct {
	MessageName   string
	ProtoFileName string
	CstructName   string
	FieldList     fieldList
	Repeated      bool // Since there could be various combinations of such types
	OneOf         bool // We need to store all of them at the global level
	Optional      bool // each case should be handled by specific nested template
}

// Defines data structure to pass to template
type fieldList struct {
	RepeatedField []elementaryField
	OneOfField    []elementaryField
	OptionalField []elementaryField
	SingleItem    bool
}

type elementaryField struct {
	MessageName     string
	ProtoFileName   string
	FieldName       string
	DataType        string
	FieldTypeName   string
	CstructName     string
	CstructLeafName string
}

// Defines data structure to pass to enum template
type enumDataStruct struct {
	MessageName   string
	ProtoFileName string
	CstructName   string
	FieldList     []elementaryField
}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// New configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}

	//TODO: Extract the SM version from the each function header. Some other values
	// could be also taken from function's header - format of parsing could be unified.
	// e.g. pass name of the .h file in the header, pass as [json_name] tag real name of the parameter in .h file.
	// As an example see EnbId, where I'm passing the same information via [json_name] tag -- this space could be reused.

	// ToDo: Discuss it with Sean

	// Missing types of structures to handle so far (TO BE UPDATED):
	// - Message with multiple Options inside --> implement with nested templates
	// - OneOf structures
	// - Repeated (generates lists)
	// - Enums (missing valid C-names of leafs and proper decoding (match data type))
	// - doesn't support anonymous structs (yet)

	for _, f := range targets { // Input .proto files
		m.Push(f.Name().String()).Debug("reporting")

		fmt.Fprintf(buf, "--- %v ---\n", f.Name().Split()[0])
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "------------------------------------------ Enums are -------------------------------------------\n")
		// ToDo: find a way how to pass comments to Enums -- [json_name] tag doesn't work
		for i, enum := range f.AllEnums() { // Constants
			fmt.Fprintf(buf, "%03d. Enum Name %v\n", i, enum.Name())
			fmt.Fprintf(buf, "%03d. Enum Descriptor %v\n", i, enum.Descriptor())
			enumData := enumDataStruct{
				MessageName:   enum.Name().String(),
				ProtoFileName: f.Name().Split()[0],
				CstructName:   "",
				FieldList:     make([]elementaryField, 0),
			}
			enumData.CstructName = enum.Name().String() // Don't know how to get it (yet)

			var listItem elementaryField

			for j, value := range enum.Descriptor().GetValue() {
				fmt.Fprintf(buf, "%03d. Enum Descriptor().GetValue().GetName() %v\n", j, value.GetName())
				fmt.Fprintf(buf, "%03d. Enum Descriptor().GetValue().GetNumber() %v\n", j, value.GetNumber())
				listItem.FieldName = value.GetName()
				listItem.ProtoFileName = f.Name().Split()[0]
				listItem.CstructLeafName = squeezeDoubleDash(value.GetName()) // Don't know how to obtain (yet)
				enumData.FieldList = append(enumData.FieldList, listItem)
			}

			tplEnum, err := template.New("enum.tpl").Funcs(template.FuncMap{
				"lowCaseFirstLetter":   lowCaseFirstLetter,
				"upperCaseFirstLetter": upperCaseFirstLetter,
				"dashToUnderscore":     dashToUnderscore,
				"underscoreToDash":     underscoreToDash,
				"tolow":                strings.ToLower,
				"cleanDashes":          cleanDashes,
			}).ParseFiles("enum.tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse template :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			m.OverwriteGeneratorTemplateFile(underscoreToDash(enumData.CstructName)+".go", tplEnum, enumData)
		}

		fmt.Fprintf(buf, "---------------------------------------- Messages are -----------------------------------------\n")
		for i, msg := range f.AllMessages() { // Messages in each of .proto files

			optional := false
			repeated := false
			oneof := false
			var cstructName string
			var items int = 0

			fieldItems := fieldList{
				RepeatedField: make([]elementaryField, 0),
				OneOfField:    make([]elementaryField, 0),
				OptionalField: make([]elementaryField, 0),
				SingleItem:    true,
			}

			flds := msg.Descriptor().GetField()
			//fmt.Fprintf(buf, "%03d. Message Descriptor() %v\n", i, msg.Descriptor())

			for _, fld := range flds {
				items++
				fmt.Fprintf(buf, "%03d. Field() -- %v\n ", i, fld.String())

				var elemField elementaryField

				elemField.FieldName = fld.GetName()
				elemField.CstructLeafName = extractCstructFieldName(fld.GetJsonName())

				cstructName = extractCstructName(fld.GetJsonName())
				elemField.CstructName = extractCstructName(fld.GetJsonName())

				elemField.DataType = convertDataType(extractDataType(fld.GetType().String()),
					extractDependentType(msg.Package().ProtoName().String(), fld.GetTypeName()))

				elemField.MessageName = msg.Name().String()
				elemField.ProtoFileName = f.Name().Split()[0]
				elemField.FieldTypeName = extractTypeName(msg.FullyQualifiedName(), msg.Package().ProtoName().String())
				//fmt.Fprintf(buf, "%03d. Message Descriptor().OneOfDecl() %v\n", i, msg.Descriptor().GetOneofDecl())

				if msg.Descriptor().GetOneofDecl() != nil {
					oneof = true
					fieldItems.OneOfField = append(fieldItems.OneOfField, elemField)
				} else {
					switch extractLabel(fld.GetLabel().String()) {
					case "OPTIONAL":
						optional = true
						fieldItems.OptionalField = append(fieldItems.OptionalField, elemField)

					case "REPEATED":
						repeated = true
						fieldItems.RepeatedField = append(fieldItems.RepeatedField, elemField)

					default: // If message has only one leaf it is still "OPTIONAL"
						optional = true
						fieldItems.OptionalField = append(fieldItems.OptionalField, elemField)

					}
				}

			}

			if items > 1 {
				fieldItems.SingleItem = false
			}

			// Filling in data structure to pass to template with correct input
			msgData := msgDataStruct{
				MessageName:   msg.Name().String(),
				ProtoFileName: f.Name().Split()[0],
				CstructName:   cstructName,
				FieldList:     fieldItems,
				OneOf:         oneof,
				Repeated:      repeated,
				Optional:      optional,
			}
			fmt.Fprintf(buf, "%03d. Gathered Message Data -- %v\n ", i, msgData)

			fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")

			tplMsg, err := template.New("message.tpl").Funcs(template.FuncMap{
				"lowCaseFirstLetter":   lowCaseFirstLetter,
				"upperCaseFirstLetter": upperCaseFirstLetter,
				"dashToUnderscore":     dashToUnderscore,
				"underscoreToDash":     underscoreToDash,
				"decodeDataType":       decodeDataType,
				"encodeDataType":       encodeDataType,
				"checkElementaryType":  checkElementaryType,
				"cleanDashes":          cleanDashes,
			}).ParseFiles("message.tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse template :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			m.OverwriteGeneratorTemplateFile(underscoreToDash(msgData.CstructName)+".go", tplMsg, msgData)
		}

		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "---------------------------------------- Dependents are -----------------------------------------\n")
		for i, dep := range f.Dependents() { // God knows what it is
			fmt.Fprintf(buf, "%03d. %v\n ", i, dep.Dependents())
		}

		m.Pop()
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")

		// TODO: Cleaning up generated code - investigate later on
		//rc, wc, _ := pipe.Commands(
		//	exec.Command("gofmt"),
		//	exec.Command("goimports"),
		//)
		//t.Execute(wc, d)
		//wc.Close()
		//io.Copy(os.Stdout, rc)

	}

	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)

	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func lowCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToLower(ch)) + str[i+1:]
	}
	return ""
}

func upperCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToUpper(ch)) + str[i+1:]
	}
	return ""
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}

func underscoreToDash(str string) string {

	return strings.ReplaceAll(str, "_", "-")
}

func extractTypeName(fullStr string, delStr string) string {

	return strings.ReplaceAll(fullStr, "."+delStr+".", "")
}

func extractCstructName(str string) string {

	if !strings.Contains(str, ":") {
		return str
	}
	return str[:strings.Index(str, ":")]
}

func extractCstructFieldName(str string) string {

	if !strings.Contains(str, ":") {
		return ""
	}
	return str[strings.Index(str, ":")+1:]
}

func squeezeDoubleDash(str string) string {

	return strings.ReplaceAll(str, "__", "_")
}

func cleanDashes(str string) string {

	return strings.ReplaceAll(str, "_", "")
}

func extractDataType(str string) string {

	return strings.ToLower(strings.ReplaceAll(str, "TYPE_", ""))
}

func extractLabel(str string) string {

	return strings.ReplaceAll(str, "LABEL_", "")
}

func extractDependentType(messageProtoName string, typeName string) string {

	return strings.ReplaceAll(typeName, "."+messageProtoName+".", "")
}

func convertDataType(str string, dependentEncoder string) string {

	switch str {
	case "int32", "uint32", "uint64":
		return str
	case "bytes":
		return "[]byte"
	case "message", "enum":
		return dependentEncoder
	default:
		return upperCaseFirstLetter(str)
	}
}

func decodeDataType(dataType string) string {

	switch dataType {
	case "int32", "uint32", "uint64":
		return dataType
	case "[]byte":
		return dataType
	case "message": //ToDo: isn't it pointless?? -- missing enum then
		return "decode" + upperCaseFirstLetter(dataType)
	default:
		return "decode" + upperCaseFirstLetter(dataType)
	}
}

func encodeDataType(dataType string) string {

	switch dataType {
	case "int32", "uint32", "uint64":
		return "C.long"
	case "[]byte":
		return dataType
	case "message": //ToDo: isn't it pointless?? -- missing enum then
		return "new" + upperCaseFirstLetter(dataType)
	default:
		return "new" + upperCaseFirstLetter(dataType)
	}
}

func checkElementaryType(dataType string) bool {

	switch dataType {
	case "int32", "uint32", "uint64", "[]byte":
		return true
	default:
		return false
	}
}
