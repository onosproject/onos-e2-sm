// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: LicenseRef-ONF-Member-1.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"strings"
	"text/template"
	"unicode"
)

const moduleName = "cgo"

// Defines data structure to pass to template
type dataStruct struct {
	MessageName   string
	ProtoFileName string
	CstructName   string
	DataType      string
	FieldName     string
	FieldTypeName string
}

// Defines data structure to pass to template
type List struct {
	Name            string
	CstructLeafName string
	ProtoFileName   string
}

// Defines data structure to pass to enum template
type enumDataStruct struct {
	MessageName   string
	ProtoFileName string
	CstructName   string
	List          []List
}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// New configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}

	//TODO: Extract the SM version from the each function header. Some other values
	// could be also taken from function's header - format of parsing could be unified.
	// e.g. pass name of the .h file in the header, pass as [json_name] tag real name of the parameter in .h file.
	// As an example see EnbId, where I'm passing the same information via [json_name] tag -- this space could be reused.

	// ToDo: Discuss it with Sean

	// Missing types of structures to handle so far (TO BE UPDATED):
	// - Message with multiple messages inside
	// - OneOf structures
	// - Repeated (generates lists)
	// - Enums (missing valid C-names of leafs and proper decoding (match data type)

	for _, f := range targets { // Input .proto files
		m.Push(f.Name().String()).Debug("reporting")

		fmt.Fprintf(buf, "--- %v ---\n", f.Name().Split()[0])
		//fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		//fmt.Fprintf(buf, "------------------------------------------ Enums are -------------------------------------------\n")
		// ToDo: find a way how to pass comments to Enums -- [json_name] tag doesn't work
		for i, enum := range f.AllEnums() { // Constants
			fmt.Fprintf(buf, "%03d. Enum Name %v\n", i, enum.Name())
			//fmt.Fprintf(buf, "%03d. Enum Descriptor %v\n", i, enum.Descriptor())
			enumData := enumDataStruct{
				MessageName:   enum.Name().String(),
				ProtoFileName: f.Name().Split()[0],
				CstructName:   "",
				List:          make([]List, 0),
			}
			enumData.CstructName = enum.Name().String() // Don't know how to get it (yet)

			var listItem List

			for j, value := range enum.Descriptor().GetValue() {
				fmt.Fprintf(buf, "%03d. Enum Descriptor().GetValue().GetName() %v\n", j, value.GetName())
				//fmt.Fprintf(buf, "%03d. Enum Descriptor().GetValue().GetNumber() %v\n", j, value.GetNumber())
				listItem.Name = value.GetName()
				listItem.CstructLeafName = squeezeDoubleDash(value.GetName()) // Don't know how to obtain (yet)
				listItem.ProtoFileName = f.Name().Split()[0]
				enumData.List = append(enumData.List, listItem)
			}

			tplEnum, err := template.New("enum.tpl").Funcs(template.FuncMap{
				"lowCaseFirstLetter":   lowCaseFirstLetter,
				"upperCaseFirstLetter": upperCaseFirstLetter,
				"dashToUnderscore":     dashToUnderscore,
				"underscoreToDash":     underscoreToDash,
				"convertDataType":      convertDataType,
				"tolow":                strings.ToLower,
			}).ParseFiles("enum.tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse template :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			m.OverwriteGeneratorTemplateFile(underscoreToDash(enumData.CstructName)+".go", tplEnum, enumData)
		}

		//fmt.Fprintf(buf, "---------------------------------------- Messages are -----------------------------------------\n")
		for i, msg := range f.AllMessages() { // Messages in each of .proto files

			// Filling in data structure to pass to template with correct input
			dataMsg := dataStruct{
				MessageName:   msg.Name().String(),
				ProtoFileName: f.Name().Split()[0],
				CstructName:   "",
				DataType:      "",
				FieldName:     "",
				FieldTypeName: "",
			}

			fmt.Fprintf(buf, "%03d. Message Name() -- %v\n ", i, lowCaseFirstLetter(msg.Name().String()))
			//fmt.Fprintf(buf, "%03d. Message Dependents() -- %v\n ", i, msg.Dependents())
			//fmt.Fprintf(buf, "%03d. Message BuildTarget() -- %v\n ", i, msg.BuildTarget())
			//fmt.Fprintf(buf, "%03d. Message Descriptor() -- %v\n ", i, msg.Descriptor()) //returning the whole (defined) structure actually
			//fmt.Fprintf(buf, "%03d. Descriptor Get Field -- %v\n ", i, msg.Descriptor().GetField())
			//fmt.Fprintf(buf, "%03d. Descriptor GetName() -- %v\n ", i, msg.Descriptor().GetName())
			//fmt.Fprintf(buf, "%03d. Descriptor GetNestedType() -- %v\n ", i, msg.Descriptor().GetNestedType())
			flds := msg.Descriptor().GetField()
			for _, fld := range flds {
				dataMsg.CstructName = extractCstructName(fld.GetJsonName())
				dataMsg.DataType = extractDataType(fld.GetType().String())
				dataMsg.FieldName = fld.GetName()
				dataMsg.FieldTypeName = extractTypeName(msg.FullyQualifiedName(), msg.Package().ProtoName().String())

				fmt.Fprintf(buf, "%03d. Field GetName() -- %v\n ", i, fld.GetName())
				//fmt.Fprintf(buf, "%03d. Field GetJsonName() -- %v\n ", i, fld.GetJsonName())
				//fmt.Fprintf(buf, "%03d. Field GetJsonName() -- %v\n ", i, dashToUnderscore(fld.GetJsonName()))
				//fmt.Fprintf(buf, "%03d. Field GetType() -- %v\n ", i, extractDataType(fld.GetType().String()))
				//fmt.Fprintf(buf, "%03d. Field GetTypeName() -- %v\n ", i, fld.GetTypeName())
				//fmt.Fprintf(buf, "%03d. Field Extracted TypeName() -- %v\n ", i, dataMsg.FieldTypeName)

			}
			//fmt.Fprintf(buf, "%03d. Descriptor GetOneofDecl() -- %v\n ", i, msg.Descriptor().GetOneofDecl()) // Checks, whether message is defined as a OneOf structure
			//fmt.Fprintf(buf, "%03d. Message FullyQualifiedName() -- %v\n ", i, msg.FullyQualifiedName())

			//fmt.Fprintf(buf, "%03d. Message Package().ProtoName() -- %v\n ", i, msg.Package().ProtoName())
			//fmt.Fprintf(buf, "%03d. Message Parent().Messages() -- %v\n ", i, msg.Parent().Messages())
			//fmt.Fprintf(buf, "%03d. Message SourceCodeInfo().LeadingComments() -- %v\n ", i, msg.SourceCodeInfo().LeadingComments()) // Here you can gather a comment on top of the message
			//fmt.Fprintf(buf, "%03d. Message Syntax() -- %v\n ", i, msg.Syntax())
			//fmt.Fprintf(buf, "%03d. Message WellKnownType() -- %v\n ", i, msg.WellKnownType())
			//fmt.Fprintf(buf, "%03d. Message NonOneOfFields() -- %v\n ", i, msg.NonOneOfFields())

			//fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")

			tplMsg, err := template.New("message.tpl").Funcs(template.FuncMap{
				"lowCaseFirstLetter":   lowCaseFirstLetter,
				"upperCaseFirstLetter": upperCaseFirstLetter,
				"dashToUnderscore":     dashToUnderscore,
				"underscoreToDash":     underscoreToDash,
				"convertDataType":      convertDataType,
			}).ParseFiles("message.tpl")
			if err != nil {
				//fmt.Errorf("couldn't parse template :/ %v", err)
				panic(err)
			}

			// Generating new .go file
			m.OverwriteGeneratorTemplateFile(underscoreToDash(dataMsg.CstructName)+".go", tplMsg, dataMsg)
		}

		//fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		//fmt.Fprintf(buf, "---------------------------------------- Dependents are -----------------------------------------\n")
		//for i, dep := range f.Dependents() { // God knows what it is
		//	fmt.Fprintf(buf, "%03d. %v\n ", i, dep.Dependents())
		//}

		m.Pop()
		//fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		//fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		//fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")

		// TODO: Cleaning up generated code - investigate later on
		//rc, wc, _ := pipe.Commands(
		//	exec.Command("gofmt"),
		//	exec.Command("goimports"),
		//)
		//t.Execute(wc, d)
		//wc.Close()
		//io.Copy(os.Stdout, rc)

	}

	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)
	
	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func lowCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToLower(ch)) + str[i+1:]
	}
	return ""
}

func upperCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToUpper(ch)) + str[i+1:]
	}
	return ""
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}

func underscoreToDash(str string) string {

	return strings.ReplaceAll(str, "_", "-")
}

func extractTypeName(fullStr string, delStr string) string {

	//return str[strings.LastIndex(str, ".")+1:]
	return strings.ReplaceAll(fullStr, "."+delStr+".", "")
}

func extractCstructName(str string) string {

	if strings.Index(str, ":") == -1 {
		return str
	} else {
		return str[:strings.Index(str, ":")]
	}
	//return strings.ReplaceAll(fullStr, "." + delStr + ".", "")
}

func squeezeDoubleDash(str string) string {

	return strings.ReplaceAll(str, "__", "_")
}

func extractDataType(str string) string {

	return strings.ToLower(strings.ReplaceAll(str, "TYPE_", ""))
}

func convertDataType(str string) string {

	switch str {
	case "int32", "uint32", "uint64":
		return str
	case "bytes":
		return "[]byte"
	default:
		return "decode" + upperCaseFirstLetter(str)
	}

}
