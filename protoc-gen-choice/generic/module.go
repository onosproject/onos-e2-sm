// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"unicode"
)

const moduleName = "choice"

var templateDir = os.Getenv("GOPATH")
var templates = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-choice/templates/choice.tpl")))

// Defines data structure to pass to enum template
type choiceStruct struct {
	PackageName      string
	Imports          string
	MapName          string
	Choices          []choiceMsg
	CanonicalChoices []canonicalChoiceMsg
}

type choiceMsg struct {
	ReffersToPackage string
	MsgName          string
	Items            []choiceItem
}

type canonicalChoiceMsg struct {
	ReffersToPackage string
	MsgName          string
	Items            []choiceItem
	// ToDo - pick best option
	ChildName string // This is to store naming of the CHOICE item (for correct referencing in index)
	IndexName string // Alternative way to store correct index
}

type choiceItem struct {
	Leafs      []leaf
	ChoiceName string
}

type leaf struct {
	Index         int
	LeafName      string
	ProtoFileName string
}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// NewModule configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}

	dir, err := os.Getwd()
	// handle err
	if err != nil {
		return nil
	}
	//printFiles(path)
	_, err = fmt.Fprintf(buf, "Working directory is %v\n", dir)
	if err != nil {
		return nil
	}

	files, err := os.ReadDir(dir)
	if err != nil {
		return nil
	}
	for _, file := range files {
		_, err = fmt.Fprintf(buf, "Found file %v\n", file.Name())
		if err != nil {
			return nil
		}
	}

	choices := choiceStruct{
		Choices:          make([]choiceMsg, 0),
		CanonicalChoices: make([]canonicalChoiceMsg, 0),
	}

	for _, f := range targets { // Input .proto files
		m.Push(f.Name().String()).Debug("reporting")
		targetPath := ""
		_, err := fmt.Fprintf(buf, "Processing following Proto file %v\n", f.File().InputPath().BaseName())
		if err != nil {
			return nil
		}
		targetPath = f.File().InputPath().Dir().String()
		_, err = fmt.Fprintf(buf, "Target file Proto path pattern is %v\n", targetPath)
		if err != nil {
			return nil
		}

		protoFilePath := ""
		err = filepath.Walk(dir,
			func(path string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if strings.Contains(path, f.File().InputPath().BaseName()+".pb.go") && !strings.Contains(path, "/_") && strings.Contains(path, targetPath) {
					protoFilePath = path
					_, err = fmt.Fprintf(buf, "Hooray! Found file %v with path %v\n", info.Name(), path)
					if err != nil {
						return nil
					}
				}

				return nil
			})
		if err != nil {
			_, err = fmt.Fprintf(buf, "Something went wrong in searching for the file path.. %v\n", err)
			if err != nil {
				return nil
			}
		}

		if protoFilePath == "" {
			_, err = fmt.Fprintf(buf, "ProtoFilePath is empty %v\n", protoFilePath)
			if err != nil {
				return nil
			}
			m.OverwriteCustomFile(
				"/tmp/report.txt",
				buf.String(),
				0644,
			)

			return m.Artifacts()
		} else {
			//Composing protoFilePath to correspond to the correct input for Golang imports
			index := strings.Index(protoFilePath, "github.com/")
			if index == -1 {
				_, err = fmt.Fprintf(buf, "Something went wrong in searching for the file path for the import..\n%v", protoFilePath)
				if err != nil {
					return nil
				}
			}
			protoFilePath = protoFilePath[index:]

			//Taking out file name from the path
			indexx := strings.LastIndex(protoFilePath, "/")
			if indexx == -1 {
				_, err = fmt.Fprintf(buf, "Something went wrong in searching for the file path for the import..\n%v", protoFilePath)
				if err != nil {
					return nil
				}
			}
			protoFilePath = protoFilePath[:indexx]

			_, err = fmt.Fprintf(buf, "Proto file path is %v\n", protoFilePath)
			if err != nil {
				return nil
			}
		}

		choices.Imports = choices.Imports + adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()) + " \"" + protoFilePath + "\"" + "\n"
		if choices.MapName == "" {
			choices.MapName = adjustMapVariableName(extractProtoFileName(f.Name().Split()[0]))
		}

		_, err = fmt.Fprintf(buf, "MapVariableName is %v\n", choices.MapName)
		if err != nil {
			return nil
		}

		for _, msg := range f.AllMessages() {
			_, err = fmt.Fprintf(buf, "OneOf list is %v\n", msg.OneOfs())
			if err != nil {
				return nil
			}
			if msg.OneOfs() != nil {
				chMsg := choiceMsg{
					MsgName: adjustOneOfStructName(msg.Name().String()),
					Items:   make([]choiceItem, 0),
				}
				for i, plg := range msg.OneOfs() {
					if !strings.HasPrefix(plg.Name().String(), "_") {
						_, err = fmt.Fprintf(buf, "%v OneOf name is %v\n", i+1, plg.Name())
						if err != nil {
							return nil
						}
						chItem := choiceItem{
							ChoiceName: plg.Name().String(),
							Leafs:      make([]leaf, 0),
						}
						for j, field := range plg.Fields() {
							_, err = fmt.Fprintf(buf, "%v, OneOf field is %v\n", j+1, field.Name())
							if err != nil {
								return nil
							}
							lf := leaf{
								Index:    j + 1,
								LeafName: msg.Name().String() + "_" + adjustOneOfLeafName(field.Name().String()),
							}
							lf.ProtoFileName = adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String())
							chItem.Leafs = append(chItem.Leafs, lf)
						}
						chMsg.Items = append(chMsg.Items, chItem)
					}
				}

				_, err = fmt.Fprintf(buf, "Obtained OneOf item is \n%v\n", chMsg)
				if err != nil {
					return nil
				}

				choices.Choices = append(choices.Choices, chMsg)
			}
		}

		m.Pop()
		_, err = fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		if err != nil {
			return nil
		}
	}

	packageName := ""
	// We are assuming that all .proto files are located at the same directory (the last directory usually contains version number)
	for _, f := range targets {
		_, err = fmt.Fprintf(buf, "Obtained input path is \n%v\n", f.InputPath().Dir().String())
		if err != nil {
			return nil
		}

		packageName = extractDirectoryName(f.InputPath().Dir().String())
		// Input .proto files
		if packageName != "" {
			choices.PackageName = dashToUnderscore(packageName)
		} else {
			choices.PackageName = adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String())
		}
		break
	}

	//Generating new .go file
	m.OverwriteGeneratorTemplateFile("choiceOptions.go", templates.Lookup("choice.tpl"), choices)

	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)

	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func upperCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToUpper(ch)) + str[i+1:]
	}
	return ""
}

func adjustOneOfLeafName(leafName string) string {

	var res string
	for _, element := range strings.Split(leafName, "_") {
		res = res + upperCaseFirstLetter(element)
	}

	return res
}

func adjustOneOfStructName(msgName string) string {

	var res string
	for i, r := range msgName {
		if unicode.IsUpper(r) {
			if i > 1 {
				res = res + "_" + strings.ToLower(string(r))
			} else {
				res = strings.ToLower(string(r))
			}
		} else {
			res = res + string(r)
		}
	}

	return res
}

func extractProtoFileName(proto string) string {

	if strings.LastIndex(proto, "/") != 1 {
		return proto[strings.LastIndex(proto, "/")+1:]
	}
	return proto
}

func adjustProtoFileName(filename string) string {

	res := dashToUnderscore(filename)
	// space for future adjustments
	return res
}

func adjustPackageName(filename string, path string) string {

	// remove redundant patterns
	res := strings.ReplaceAll(filename, "_go", "")

	//extract version number
	index := strings.LastIndex(path, "/v")
	version := path[index+1:]

	// clarify if the version is not already present in the filename
	present := strings.Contains(res, version)

	//check if another versioning number presents in the naming - relevant for external dependencies
	re := regexp.MustCompile(`v\d{1}`)
	externalVersion := re.MatchString(res)

	if version != "" && !present && !externalVersion {
		res = res + version
	}

	//remove all underscores
	res = strings.ReplaceAll(res, "_", "")
	//remove all camel cases
	res = strings.ToLower(res)

	return res
}

func adjustMapVariableName(mapName string) string {

	flag := true
	for flag {
		index := strings.IndexAny(mapName, "_")
		if index == -1 {
			flag = false
		} else {
			// Assumption - string doesn't end with "_"
			mapName = mapName[:index] + strings.ToUpper(mapName[index+1:index+2]) + mapName[index+2:]
		}
	}
	mapName = strings.ReplaceAll(mapName, "Go", "")
	//ToDo - make a workaround through regexp
	mapName = strings.ReplaceAll(mapName, "V1", "")
	mapName = strings.ReplaceAll(mapName, "V2", "")
	mapName = strings.ReplaceAll(mapName, "V3", "")
	mapName = strings.ReplaceAll(mapName, "V4", "")

	return mapName
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}

func extractDirectoryName(str string) string {

	res := ""
	index := strings.LastIndex(str, "/")
	if index != -1 {
		res = str[index+1:]
	} else {
		res = str
	}

	return res
}
