// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"
)

const moduleName = "choice"

var templateDir = os.Getenv("GOPATH")
var templates = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-choice/templates/choice.tpl")))

// Defines data structure to pass to enum template
type choiceStruct struct {
	ProtoFileName    string
	Imports          string
	MapName          string
	Choices          []choiceMsg
	CanonicalChoices []choiceMsg
}

type choiceMsg struct {
	MsgName string
	Items   []choiceItem
}

type choiceItem struct {
	Leafs      []leaf
	ChoiceName string
}

type leaf struct {
	Index          int
	LeafName       string
	OtherProtoName string
	FromOtherProto bool
}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// NewModule configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}

	path, err := os.Getwd()
	// handle err
	if err != nil {
		return nil
	}
	//printFiles(path)
	_, err = fmt.Fprintf(buf, "Working directory is %v\n", path)
	if err != nil {
		return nil
	}

	files, err := os.ReadDir(path)
	if err != nil {
		return nil
	}
	for _, file := range files {
		_, err = fmt.Fprintf(buf, "Found file %v\n", file.Name())
		if err != nil {
			return nil
		}
	}

	choices := choiceStruct{
		//ProtoFileName: "",
		//MapName:       "",
		Choices:          make([]choiceMsg, 0),
		CanonicalChoices: make([]choiceMsg, 0),
	}

	for _, f := range targets { // Input .proto files
		m.Push(f.Name().String()).Debug("reporting")
		_, err := fmt.Fprintf(buf, "Processing following Proto file %v\n", f.InputPath())
		if err != nil {
			return nil
		}

		if choices.ProtoFileName == "" {
			choices.ProtoFileName = adjustProtoFileName(extractProtoFileName(f.Name().Split()[0]))
			choices.Imports = choices.Imports + "\n" + adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])) + " \"" + f.Package().Files()[0].Name().String() + "\"" // f.Name().String()
		}
		if choices.MapName == "" {
			choices.MapName = adjustMapVariableName(extractProtoFileName(f.Name().Split()[0]))
		}

		_, err = fmt.Fprintf(buf, "ProtoFileName is %v\n", choices.ProtoFileName)
		if err != nil {
			return nil
		}
		_, err = fmt.Fprintf(buf, "MapVariableName is %v\n", choices.MapName)
		if err != nil {
			return nil
		}

		for _, msg := range f.AllMessages() {
			_, err = fmt.Fprintf(buf, "OneOf list is %v\n", msg.OneOfs())
			if err != nil {
				return nil
			}
			if msg.OneOfs() != nil {
				chMsg := choiceMsg{
					MsgName: adjustOneOfStructName(msg.Name().String()),
					Items:   make([]choiceItem, 0),
				}
				for i, plg := range msg.OneOfs() {
					if !strings.HasPrefix(plg.Name().String(), "_") {
						_, err = fmt.Fprintf(buf, "%v OneOf name is %v\n", i+1, plg.Name())
						if err != nil {
							return nil
						}
						chItem := choiceItem{
							ChoiceName: plg.Name().String(),
							Leafs:      make([]leaf, 0),
						}
						for j, field := range plg.Fields() {
							//plg.Fields()
							_, err = fmt.Fprintf(buf, "%v, OneOf field is %v\n", j+1, field.Name())
							if err != nil {
								return nil
							}
							lf := leaf{
								Index:          j + 1,
								LeafName:       msg.Name().String() + "_" + adjustOneOfLeafName(field.Name().String()),
								FromOtherProto: false,
							}
							if adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])) != choices.ProtoFileName {
								lf.OtherProtoName = adjustProtoFileName(extractProtoFileName(f.Name().Split()[0]))
								lf.FromOtherProto = true
							}
							chItem.Leafs = append(chItem.Leafs, lf)
						}
						chMsg.Items = append(chMsg.Items, chItem)
					}
				}

				//for j, oneof := range msg.OneOfFields() {
				//	oneofItem := choiceItem{
				//		Index:    j + 1,
				//		LeafName: msg.Name().String() + "_" + adjustOneOfLeafName(oneof.Name().String()),
				//	}
				//	chItem.Leafs = append(chItem.Leafs, oneofItem)
				//	fmt.Fprintf(buf, "Obtained OneOf leaf is \n%v\n", oneofItem)
				//}
				_, err = fmt.Fprintf(buf, "Obtained OneOf item is \n%v\n", chMsg)
				if err != nil {
					return nil
				}

				choices.Choices = append(choices.Choices, chMsg)
			}
		}

		m.Pop()
		_, err = fmt.Fprintf(buf, "-----------------------------------------------------------------------------------------------\n")
		if err != nil {
			return nil
		}
	}

	//Generating new .go file
	m.OverwriteGeneratorTemplateFile("choiceOptions.go", templates.Lookup("choice.tpl"), choices)

	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)

	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func upperCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToUpper(ch)) + str[i+1:]
	}
	return ""
}

func adjustOneOfLeafName(leafName string) string {

	var res string
	for _, element := range strings.Split(leafName, "_") {
		res = res + upperCaseFirstLetter(element)
	}

	return res
}

func adjustOneOfStructName(msgName string) string {

	var res string
	for i, r := range msgName {
		if unicode.IsUpper(r) {
			if i > 1 {
				res = res + "_" + strings.ToLower(string(r))
			} else {
				res = strings.ToLower(string(r))
			}
		} else {
			res = res + string(r)
		}
	}

	return res
}

func extractProtoFileName(proto string) string {

	if strings.LastIndex(proto, "/") != 1 {
		return proto[strings.LastIndex(proto, "/")+1:]
	}
	return proto
}

func adjustProtoFileName(filename string) string {

	res := dashToUnderscore(filename)
	// space for future adjustments
	return res
}

func adjustMapVariableName(mapName string) string {

	flag := true
	for flag {
		index := strings.IndexAny(mapName, "_")
		if index == -1 {
			flag = false
		} else {
			// Assumption - string doesn't end with "_"
			mapName = mapName[:index] + strings.ToUpper(mapName[index+1:index+2]) + mapName[index+2:]
		}
	}
	mapName = strings.ReplaceAll(mapName, "Go", "")
	//ToDo - make a work around through regexp
	mapName = strings.ReplaceAll(mapName, "V1", "")
	mapName = strings.ReplaceAll(mapName, "V2", "")
	mapName = strings.ReplaceAll(mapName, "V3", "")
	mapName = strings.ReplaceAll(mapName, "V4", "")

	return mapName
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}
