// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"unicode"
)

const moduleName = "builder"

var templateDir = os.Getenv("GOPATH")
var templateEncoder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/encoder.tpl")))

//var templatePdubuilder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/pdubuilder.tpl")))
//var templateBuilder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/builder.tpl")))
//var templateServicemodel = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/servicemodel.tpl")))

// encoder structure carries all necessary items to generate the encoder package
type encoder struct {
	Logger                  bool   // this is to indicate of logger was initialized - one structure should be randomly picked and assigned a logger flag
	Imports                 string // this is to hold all necessary imports, mainly the Protobuf which contains top-level PDUs (they're defined as PDUs with multiple formats wrapped as a nested CHOICE inside SEQUENCE)
	ProtoName               string // this is to hold ProtobufName to refer to the same package
	MessageName             string // top-level PDU message name
	MessageNameInLogging    string // this is to hold message name in the logs
	ChoiceMapName           string // this is to hold choice map name
	CanonicalChoiceMapName  string // this is to hold canonical choice map name
	CanonicalChoicePresence bool   // indicates whether Canonical ordering for choices is present and the map should be passed
	Parameters              string // this is to hold all necessary parameters to pass to the message - mostly it is "choiceExt" or "valueExt"
}

// servicemodel structure carries all necessary items to generate the servicemodel package
type servicemodel struct {
	SmName  string // SM name
	Imports string // this is to hold all necessary imports, mainly the Protobuf which contains top-level PDUs (they're defined as PDUs with multiple formats wrapped as a nested CHOICE inside SEQUENCE)
}

// ToDo - find out how to handle pdubuilder package generation
type pdubuilder struct {
}

// Defines data structure to pass to enum template
type choiceStruct struct {
	PackageName             string
	Imports                 string
	MapName                 string
	Choices                 []choiceMsg
	CanonicalChoices        []canonicalChoiceMsg
	CanonicalChoicePresence bool
}

type choiceMsg struct {
	MsgName string
	Items   []choiceItem
}

type choiceItem struct {
	Leafs      []leaf
	ChoiceName string
}

type leaf struct {
	Index         int
	LeafName      string
	ProtoFileName string
}

type canonicalChoiceMsg struct {
	MsgName string
	Items   []canonicalChoiceItem
}

type canonicalChoiceItem struct {
	Leafs      []canonicalLeaf
	ChoiceName string
}

type canonicalLeaf struct {
	Index         string
	LeafName      string
	ProtoFileName string
	PackageName   string
	ItemType      string // This is to store type of the CHOICE item (for correct referencing in index)
}

//type canonicalChoicesList struct {
//	Name string
//}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// NewModule configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}

	// firstly, understanding what to generate - servicemodel (E2SM) or E2AP
	sm, _ := m.Parameters().Bool("sm")

	dir, err := os.Getwd()
	// handle err
	if err != nil {
		return nil
	}
	//printFiles(path)
	_, err = fmt.Fprintf(buf, "Working directory is %v\n", dir)
	if err != nil {
		return nil
	}

	files, err := os.ReadDir(dir)
	if err != nil {
		return nil
	}
	for _, file := range files {
		_, err = fmt.Fprintf(buf, "Found file %v\n", file.Name())
		if err != nil {
			return nil
		}
	}

	// creating structure to make generate encoder
	enc := make([]encoder, 0)
	loggerPresence := true
	if sm {
		for _, f := range targets { // Input .proto files

			// understanding if canonical choice ordering is present
			canonicalChoice := canonicalOrderingIsPresent(f.AllMessages())

			// looking for a proto path here
			protoFilePath := lookUpProtoFilePath(dir, f.File().InputPath())

			for _, msg := range f.AllMessages() {
				_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
				if err != nil {
					return nil
				}
				// This indicates us that we've found top-level message
				if strings.Contains(msg.Name().String(), "E2Sm") &&
					!strings.Contains(msg.Name().String(), "Format") && !strings.Contains(msg.Name().String(), "Item") {
					//msg.Name().String()
					_, err = fmt.Fprintf(buf, "Top-level message was found!! It is %v\n", msg.Name().String())
					if err != nil {
						return nil
					}

					_, err = fmt.Fprintf(buf, "Comments were found, they are:\n%v\n", msg.SourceCodeInfo().LeadingComments())
					if err != nil {
						return nil
					}

					pdu := encoder{
						ProtoName:               adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()),
						MessageName:             msg.Name().String(),
						MessageNameInLogging:    adjustMessageNameForLogging(msg.Name().String()),
						ChoiceMapName:           adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "Choicemap",
						CanonicalChoiceMapName:  adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "CanonicalChoicemap",
						CanonicalChoicePresence: canonicalChoice,
						Parameters:              lookUpMessageParameters(msg.SourceCodeInfo().LeadingComments()),
					}
					if loggerPresence {
						pdu.Logger = true
						loggerPresence = false
					} else {
						pdu.Logger = false
					}
					pdu.Imports = pdu.ProtoName + " \"" + protoFilePath + "\"" + "\n"
					enc = append(enc, pdu)
				}
			}
		}
	} else {
		// There is only single top-level PDU so far, but leaving it here for future
		for _, f := range targets { // Input .proto files

			// understanding if canonical choice ordering is present
			canonicalChoice := canonicalOrderingIsPresent(f.AllMessages())

			// looking for a proto path here
			protoFilePath := lookUpProtoFilePath(dir, f.File().InputPath())

			for _, msg := range f.AllMessages() {
				_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
				if err != nil {
					return nil
				}
				// This indicates us that we've found top-level message
				if strings.Contains(msg.Name().String(), "E2Ap") &&
					!strings.Contains(msg.Name().String(), "Format") && !strings.Contains(msg.Name().String(), "Item") {
					//msg.Name().String()
					_, err = fmt.Fprintf(buf, "Top-level message was found!! It is %v\n", msg.Name().String())
					if err != nil {
						return nil
					}
					// Stick to the E2AP message
					pdu := encoder{
						Logger:                  true,
						ProtoName:               adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()),
						MessageName:             msg.Name().String(),
						MessageNameInLogging:    "E2AP",
						ChoiceMapName:           adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "Choicemap",
						CanonicalChoiceMapName:  adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "CanonicalChoicemap",
						CanonicalChoicePresence: canonicalChoice,
						Parameters:              lookUpMessageParameters(msg.SourceCodeInfo().LeadingComments()),
					}
					pdu.Imports = pdu.ProtoName + " \"" + protoFilePath + "\"" + "\n"
					enc = append(enc, pdu)
				}
			}
		}
	}

	_, err = fmt.Fprintf(buf, "We're about to start generating encoder package\nObtained structure is %v\n", enc)
	if err != nil {
		return nil
	}

	//printing encoder files..
	for _, e := range enc {
		_, err = fmt.Fprintf(buf, "Generating template for %v with name %v\n", e.MessageName, e.MessageNameInLogging)
		if err != nil {
			return nil
		}

		//Generating new .go file
		m.OverwriteGeneratorTemplateFile(e.MessageNameInLogging+".go", templateEncoder.Lookup("encoder.tpl"), e)
	}

	if sm {
		//ToDo - generate servicemodel package

	}

	out := m.OutputPath()
	_, err = fmt.Fprintf(buf, "Output path is\n%v\n", out)
	if err != nil {
		return nil
	}

	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)

	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func upperCaseFirstLetter(str string) string {

	for i, ch := range str {
		return string(unicode.ToUpper(ch)) + str[i+1:]
	}
	return ""
}

func adjustOneOfLeafName(leafName string) string {

	var res string
	for _, element := range strings.Split(leafName, "_") {
		res = res + upperCaseFirstLetter(element)
	}

	return res
}

func adjustOneOfStructName(msgName string) string {

	var res string
	for i, r := range msgName {
		if unicode.IsUpper(r) {
			if i > 1 {
				res = res + "_" + strings.ToLower(string(r))
			} else {
				res = strings.ToLower(string(r))
			}
		} else {
			res = res + string(r)
		}
	}

	return res
}

func extractProtoFileName(proto string) string {

	if strings.LastIndex(proto, "/") != -1 {
		return proto[strings.LastIndex(proto, "/")+1:]
	}
	return proto
}

func extractPackageName(pckg string) string {

	if strings.Contains(pckg, "/") {
		return pckg[:strings.Index(pckg, "/")]
	}
	return pckg
}

func extractPackageNameForCanonicalChoices(path string) string {

	re := regexp.MustCompile(`v\d{1}`)
	res := re.FindString(path)
	return res
}

func adjustProtoFileName(filename string) string {

	res := dashToUnderscore(filename)
	// space for future adjustments
	return res
}

func adjustPackageName(filename string, path string) string {

	// remove redundant patterns
	res := strings.ReplaceAll(filename, "_go", "")

	//extract version number
	index := strings.LastIndex(path, "/v")
	version := path[index+1:]

	// clarify if the version is not already present in the filename
	present := strings.Contains(res, version)

	//check if another versioning number presents in the naming - relevant for external dependencies
	re := regexp.MustCompile(`v\d{1}`)
	externalVersion := re.MatchString(res)

	if version != "" && !present && !externalVersion {
		res = res + version
	}

	//remove all underscores
	res = strings.ReplaceAll(res, "_", "")
	//remove all camel cases
	res = strings.ToLower(res)

	return res
}

func adjustMapVariableName(mapName string) string {

	flag := true
	for flag {
		index := strings.IndexAny(mapName, "_")
		if index == -1 {
			flag = false
		} else {
			// Assumption - string doesn't end with "_"
			mapName = mapName[:index] + strings.ToUpper(mapName[index+1:index+2]) + mapName[index+2:]
		}
	}
	mapName = strings.ReplaceAll(mapName, "Go", "")
	//ToDo - make a workaround through regexp
	//re := regexp.MustCompile(`v\d{1}`)
	//mapName = re.ReplaceAllString(mapName, "")
	mapName = strings.ReplaceAll(mapName, "V1", "")
	mapName = strings.ReplaceAll(mapName, "v1", "")
	mapName = strings.ReplaceAll(mapName, "V2", "")
	mapName = strings.ReplaceAll(mapName, "v2", "")
	mapName = strings.ReplaceAll(mapName, "V3", "")
	mapName = strings.ReplaceAll(mapName, "v3", "")
	mapName = strings.ReplaceAll(mapName, "V4", "")
	mapName = strings.ReplaceAll(mapName, "v4", "")

	return strings.ToUpper(mapName[:1]) + mapName[1:]
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}

func extractDirectoryName(str string) string {

	res := ""
	index := strings.LastIndex(str, "/")
	if index != -1 {
		res = str[index+1:]
	} else {
		res = str
	}

	return res
}

func getItemType(str string) string {

	res := ""
	index := strings.LastIndex(str, ".")
	if index != -1 {
		res = str[index+1:]
	} else {
		res = "ErrorInParsing"
	}

	return res
}

func presentInCanonicalChoiceList(target string, list []string) bool {

	flag := false
	for _, item := range list {
		if strings.EqualFold(item, target) {
			flag = true
		}
	}

	return flag
}

func adjustCanonicalChoiceIndex(name string, structType string) string {

	res := ""
	// Assuming that all names start from Id which should be cut out
	newName := name[2:]
	//newName := strings.ReplaceAll(name, "Id", "")
	newStructType := strings.ReplaceAll(structType, "-", "") // could contain "ID"

	tmp := newStructType + newName
	if !strings.Contains(strings.ToLower(newStructType), "id") {
		tmp = newStructType + "ID" + newName
	}

	res = strings.ReplaceAll(tmp, "\n", "")
	res = strings.ReplaceAll(res, "IE", "Ie")
	res = strings.ReplaceAll(res, "Id", "ID")
	res = strings.ReplaceAll(res, " ", "")
	return res
}

func lookUpCanonicalChoiceIndex(name string, list []string) string {

	res := ""
	for _, item := range list {
		if strings.Contains(strings.ToLower(item), strings.ToLower(name)) {
			res = item
			break
		}
	}

	if res == "" {
		res = "NoIndexDefined"
	}
	return res
}

func adjustMessageNameForLogging(name string) string {

	res := ""
	e2Name := adjustMapVariableName(extractPackageName(name))
	if strings.Contains(strings.ToLower(name), "e2sm") {
		tmp := "E2SM" + "-" + name[4:]
		res = strings.ReplaceAll(tmp, e2Name, strings.ToUpper(e2Name)+"-")
	} else if strings.Contains(strings.ToLower(name), "e2ap") {
		//ToDo - shouldn't be valid for E2AP - leaving for future
		tmp := "E2AP" + "-" + name[4:]
		res = strings.ReplaceAll(tmp, e2Name, strings.ToUpper(e2Name)+"-")
	}

	return res
}

func lookUpMessageParameters(comments string) string {

	res := ""
	if strings.Contains(comments, "aper:") {
		index1 := strings.Index(comments, "aper:\"")
		tmp := comments[index1+6:]
		index2 := strings.Index(tmp, "\"")
		res = tmp[:index2]
	}

	return res
}

func canonicalOrderingIsPresent(files []pgs.Message) bool {
	canonicalChoice := false
	// understanding if there is a canonical choice presence
	for _, msg := range files {
		for _, item := range msg.Fields() {
			if strings.Contains(item.SourceCodeInfo().LeadingComments(), "canonicalOrder") {
				canonicalChoice = true
				break
			}
		}
	}

	return canonicalChoice
}

func lookUpProtoFilePath(dir string, inputPath pgs.FilePath) string {

	targetPath := ""
	targetPath = inputPath.Dir().String()

	protoFilePath := ""
	err := filepath.Walk(dir,
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if strings.Contains(path, inputPath.BaseName()+".pb.go") && !strings.Contains(path, "/_") && strings.Contains(path, targetPath) {
				protoFilePath = path
			}

			return nil
		})
	if err != nil {
		return "Something went wrong in searching for the file path.."
	}

	if protoFilePath == "" {
		return "EmptyProtoFilePath"
	} else {
		//Composing protoFilePath to correspond to the correct input for Golang imports
		index := strings.Index(protoFilePath, "github.com/")
		if index == -1 {
			return "Something went wrong in searching for the file path for the import.."
		}
		protoFilePath = protoFilePath[index:]

		//Taking out file name from the path
		indexx := strings.LastIndex(protoFilePath, "/")
		if indexx == -1 {
			return "Something went wrong in searching for the file path for the import.."
		}
		protoFilePath = protoFilePath[:indexx]
	}

	return protoFilePath
}
