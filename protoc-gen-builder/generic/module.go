// SPDX-FileCopyrightText: 2022-present Intel Corporation
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"unicode"
)

const moduleName = "builder"

var templateDir = os.Getenv("GOPATH")
var templateEncoder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/encoder.tpl")))

var templatePdubuilder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/pdubuilder.tpl")))
var templateBuilder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/builder.tpl")))
var templateServicemodel = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/servicemodel.tpl")))

// encoder structure carries all necessary items to generate the encoder package
type encoder struct {
	Logger                  bool   // this is to indicate of logger was initialized - one structure should be randomly picked and assigned a logger flag
	Imports                 string // this is to hold all necessary imports, mainly the Protobuf which contains top-level PDUs (they're defined as PDUs with multiple formats wrapped as a nested CHOICE inside SEQUENCE)
	ProtoName               string // this is to hold ProtobufName to refer to the same package
	MessageName             string // top-level PDU message name
	MessageNameInLogging    string // this is to hold message name in the logs
	ChoiceMapName           string // this is to hold choice map name
	CanonicalChoiceMapName  string // this is to hold canonical choice map name
	CanonicalChoicePresence bool   // indicates whether Canonical ordering for choices is present and the map should be passed
	Parameters              string // this is to hold all necessary parameters to pass to the message - mostly it is "choiceExt" or "valueExt"
}

// servicemodel structure carries all necessary items to generate the servicemodel package
type servicemodel struct {
	PackageName  string
	E2SmName     string       // E2SM name without E2 prefix and in uppercase
	Imports      string       // this is to hold all necessary imports, mainly the Protobuf which contains top-level PDUs (they're defined as PDUs with multiple formats wrapped as a nested CHOICE inside SEQUENCE)
	SmName       string       // SM name composed of E2SmName and SmVersion variable both in lowercase
	SmVersion    string       // SM version
	OID          string       // SM OID
	TopLevelPdus topLevelPdus // this is to hold information about top-level PDUs
}

// topLevelPdus structure holds SM interface information for top-level PDUs
type topLevelPdus struct {
	IndicationHeader       topLevelPdu
	IndicationMessage      topLevelPdu
	ControlHeader          topLevelPdu
	ControlMessage         topLevelPdu
	ControlOutcome         topLevelPdu
	RanFunctionDescription topLevelPdu
	EventTriggerDefinition topLevelPdu
	ActionDefinition       topLevelPdu
	CallProcessID          topLevelPdu
}

type topLevelPdu struct {
	MessageProtoName string // this is to hold Protobuf name of the message
	IsPresent        bool   // this is to indicate if the PDU is present
}

type builder struct {
	PackageName string
	Imports     string
	Instances   []builderInstance // set of optional items in the message
}

type builderInstance struct {
	Instance        string
	FunctionName    string
	ItemType        string
	ItemName        string
	VariableName    string
	VariableNamePtr string
}

type protoItem struct {
	PackageName   string
	ProtoFilePath string // this is to store patch for importing this item, import will be composed of PackageName and ProtoFilePath
	IsChoice      bool
	IsEnum        bool
	IsList        bool
}

type pdubuilder struct {
	Imports   string
	Instances []pdubuilderInstance
}

type pdubuilderInstance struct {
	PackageName        string
	FunctionName       string
	FunctionOutputType string
	Items              []pdubuilderItem
	SingleItem         bool
}

type pdubuilderItem struct {
	VariableName string
	FieldName    string
	ItemType     string
	IsChoice     bool
	IsEnum       bool
	IsList       bool
}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// NewModule configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}

	// firstly, understanding what to generate - servicemodel (E2SM) or E2AP
	sm, _ := m.Parameters().Bool("sm")

	dir, err := os.Getwd()
	// handle err
	if err != nil {
		return nil
	}
	//printFiles(path)
	_, err = fmt.Fprintf(buf, "Working directory is %v\n", dir)
	if err != nil {
		return nil
	}

	files, err := os.ReadDir(dir)
	if err != nil {
		return nil
	}
	for _, file := range files {
		_, err = fmt.Fprintf(buf, "Found file %v\n", file.Name())
		if err != nil {
			return nil
		}
	}

	// creating structure to generate encoder package
	enc := make([]encoder, 0)
	loggerPresence := true

	//creating structure to generate servicemodel package
	smodel := servicemodel{}

	if sm {
		smBasicInfoFilled := false
		for _, f := range targets { // Input .proto files
			m.Push(f.Name().String()).Debug("reporting")
			_, err = fmt.Fprintf(buf, "Leading target comments were found, they are:\n%v\n", f.SourceCodeInfo().LeadingDetachedComments())
			if err != nil {
				return nil
			}

			// understanding if canonical choice ordering is present
			canonicalChoice := canonicalOrderingIsPresent(f.AllMessages())

			// looking for a proto path here
			protoFilePath := lookUpProtoFilePath(dir, f.File().InputPath())

			for _, msg := range f.AllMessages() {
				_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
				if err != nil {
					return nil
				}
				// This indicates us that we've found top-level message
				if strings.Contains(msg.Name().String(), "E2Sm") &&
					!strings.Contains(msg.Name().String(), "Format") && !strings.Contains(msg.Name().String(), "Item") {

					_, err = fmt.Fprintf(buf, "Top-level message was found!! It is %v\n", msg.Name().String())
					if err != nil {
						return nil
					}

					_, err = fmt.Fprintf(buf, "Comments were found, they are:\n%v\n", msg.SourceCodeInfo().LeadingComments())
					if err != nil {
						return nil
					}

					pdu := encoder{
						ProtoName:               adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()),
						MessageName:             msg.Name().String(),
						MessageNameInLogging:    adjustMessageNameForLogging(msg.Name().String()),
						ChoiceMapName:           adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "Choicemap",
						CanonicalChoiceMapName:  adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "CanonicalChoicemap",
						CanonicalChoicePresence: canonicalChoice,
						Parameters:              lookUpMessageParameters(msg.SourceCodeInfo().LeadingComments()),
					}
					if loggerPresence {
						pdu.Logger = true
						loggerPresence = false
					} else {
						pdu.Logger = false
					}
					pdu.Imports = pdu.ProtoName + " \"" + protoFilePath + "\"" + "\n"
					enc = append(enc, pdu)

					// filling in some information about SM
					smodel.ParsePdu(msg.Name().String())
					if !smBasicInfoFilled {
						smodel.ParseSmData(f.SourceCodeInfo().LeadingDetachedComments())
						smodel.Imports = smodel.SmName + " \"" + protoFilePath + "\"" + "\n"
						smodel.AddEncoderImport(protoFilePath)
						smBasicInfoFilled = true
					}
				}
			}
		}
	} else {
		// There is only single top-level PDU so far, but leaving it here for future
		for _, f := range targets { // Input .proto files
			m.Push(f.Name().String()).Debug("reporting")
			// understanding if canonical choice ordering is present
			canonicalChoice := canonicalOrderingIsPresent(f.AllMessages())

			// looking for a proto path here
			protoFilePath := lookUpProtoFilePath(dir, f.File().InputPath())

			for _, msg := range f.AllMessages() {
				_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
				if err != nil {
					return nil
				}
				// This indicates us that we've found top-level message
				if strings.Contains(msg.Name().String(), "E2ApPdu") &&
					!strings.Contains(msg.Name().String(), "Format") && !strings.Contains(msg.Name().String(), "Item") {

					_, err = fmt.Fprintf(buf, "Top-level message was found!! It is %v\n", msg.Name().String())
					if err != nil {
						return nil
					}
					// Stick to the E2AP message
					pdu := encoder{
						Logger:                  true,
						ProtoName:               adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()),
						MessageName:             msg.Name().String(),
						MessageNameInLogging:    "E2AP",
						ChoiceMapName:           adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "Choicemap",
						CanonicalChoiceMapName:  adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "CanonicalChoicemap",
						CanonicalChoicePresence: canonicalChoice,
						Parameters:              lookUpMessageParameters(msg.SourceCodeInfo().LeadingComments()),
					}
					pdu.Imports = pdu.ProtoName + " \"" + protoFilePath + "\"" + "\n"
					enc = append(enc, pdu)
				}
			}
		}
	}

	// creating list of all messages and their correspondence to certain .proto file/package
	tree := map[string]protoItem{}
	_, err = fmt.Fprintf(buf, "There are multiple .proto files passed at input, building a simple tree of the messages")
	if err != nil {
		return nil
	}
	for _, f := range targets { // Input .proto files
		_, err = fmt.Fprintf(buf, "Proto package name is %v\n", f.Package().ProtoName().String())
		if err != nil {
			return nil
		}
		packageName := adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String())

		_, err = fmt.Fprintf(buf, "Iterating over the messages in %v\n", f.Package().ProtoName().String())
		if err != nil {
			return nil
		}
		for _, msg := range f.AllMessages() {
			_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
			if err != nil {
				return nil
			}
			itemName := msg.Name().String()
			leaf := protoItem{
				PackageName:   packageName,
				ProtoFilePath: lookUpProtoFilePath(dir, f.File().InputPath()),
			}

			_, err = fmt.Fprintf(buf, "Message name is %v, oneOf items are %v, non-oneOf items are %v\n", msg.Name().String(), len(msg.OneOfs()), len(msg.NonOneOfFields()))
			if err != nil {
				return nil
			}

			// avoiding parsing constants && checking if this is a list
			if !strings.Contains(msg.SourceCodeInfo().LeadingComments(), "constant") &&
				len(msg.Fields()) == 1 && strings.Contains(strings.ToLower(msg.Name().String()), "list") {
				leaf.IsList = msg.Fields()[0].Type().IsRepeated()
			}
			// avoiding parsing constants && checking if this is a oneOf (CHOICE)
			if !strings.Contains(msg.SourceCodeInfo().LeadingComments(), "constant") &&
				len(msg.OneOfs()) > 0 && len(msg.NonOneOfFields()) == 0 { // it also excludes the case when optional items is interpreted as a oneOf
				leaf.IsChoice = true
			}

			tree[itemName] = leaf
		}

		// processing enumerators and adding to the tree
		for _, enum := range f.AllEnums() { // Constants
			leaf := protoItem{
				PackageName:   packageName,
				ProtoFilePath: lookUpProtoFilePath(dir, f.File().InputPath()),
				IsEnum:        true,
			}
			tree[enum.Name().String()] = leaf
		}
	}
	_, err = fmt.Fprintf(buf, "Obtained Protobuf tree:\n%v\n", tree)
	if err != nil {
		return nil
	}

	// gathering data for builder
	for _, f := range targets { // Input .proto files
		m.Push(f.Name().String()).Debug("reporting")

		// this package should be located in the same directory as .pb.go
		bldr := builder{
			PackageName: adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()),
			Imports:     "",
			Instances:   make([]builderInstance, 0),
		}

		_, err = fmt.Fprintf(buf, "Processing file %v\n", f.Name().String())
		if err != nil {
			return nil
		}

		// iterating over messages and collecting set of OPTIONAL items
		for _, msg := range f.AllMessages() {
			_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
			if err != nil {
				return nil
			}
			// avoiding parsing constants
			if !strings.Contains(msg.SourceCodeInfo().LeadingComments(), "constant") {
				// iterating over fields of the message
				for _, dep := range msg.Fields() {
					// This indicates us that we've found OPTIONAL item in the message
					if strings.Contains(dep.SourceCodeInfo().LeadingComments(), "optional") {
						_, err = fmt.Fprintf(buf, "Hooray! Found OPTIONAL item - %v\n", dep.Name().String())
						if err != nil {
							return nil
						}
						instanceName := msg.Name().String()
						itemType := adjustFieldName(extractItemMessageType(dep))
						// checking if the message is of type BitString (special case)
						if strings.Contains(itemType, "BitString") {
							bldr.Imports = bldr.Imports + "\n\"github.com/onosproject/onos-lib-go/api/asn1/v1/asn1\"\n"
						}
						// checking if the message is of the elementary type
						elementaryType := false
						elementaryType = isElementaryType(itemType)

						itemName := adjustFieldName(composeItemName(dep.Name().String()))
						instance := builderInstance{
							Instance:     instanceName,
							FunctionName: itemName,
							ItemName:     itemName,
							ItemType:     itemType,
							VariableName: strings.ToLower(itemName[:1]) + itemName[1:],
						}

						// getting information about the item from the own Protobuf tree
						item, ok := tree[itemType]
						if !ok {
							_, err = fmt.Fprintf(buf, "Couldn't find the message %v in the Protobuf tree\n", itemName)
							if err != nil {
								return nil
							}
						}

						// checking if the message is defined in the other Protobuf file
						_, err = fmt.Fprintf(buf, "Current package name is %v, item %v is from package %v\n",
							adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()), adjustFieldName(itemType), item.PackageName)
						if err != nil {
							return nil
						}
						if item.fromOtherProto(adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String())) {
							tmp := instance.ItemType
							instance.ItemType = item.PackageName + "." + tmp
							if !strings.Contains(bldr.Imports, item.PackageName) {
								bldr.Imports = bldr.Imports + "\n" + item.getImport()
							}
						}

						// avoiding case when it's an enumerator
						if strings.Contains(dep.SourceCodeInfo().LeadingComments(), "valueLB:") && strings.Contains(dep.SourceCodeInfo().LeadingComments(), "valueUB:") {
							instance.VariableNamePtr = "&" + instance.VariableName
						} else {
							if !elementaryType {
								instance.ItemType = "*" + instance.ItemType
								instance.VariableNamePtr = instance.VariableName
							} else {
								//treating special case
								if !strings.Contains(instance.ItemType, "[]byte") {
									instance.VariableNamePtr = "&" + instance.VariableName
								} else {
									instance.VariableNamePtr = instance.VariableName
								}
							}
							// treating the case of the list
							if strings.Contains(strings.ToLower(instance.ItemName), "list") && !strings.Contains(strings.ToLower(instance.ItemType), "list") {
								instance.ItemType = "[]" + instance.ItemType
							}
						}
						// linting some of the fields
						instance.doLinting()
						bldr.Instances = append(bldr.Instances, instance)
					}
				}
			}
		}
		_, err = fmt.Fprintf(buf, "We're about to start generating builder foo Protobuf\nObtained structure is %v\n", bldr)
		if err != nil {
			return nil
		}

		// looking for a proto path to locate where to store builder file
		protoFilePath := lookUpProtoFilePath(dir, f.File().InputPath())
		_, err = fmt.Fprintf(buf, "Protobuf file path is %v\nFile's Input path is %v\n", protoFilePath, f.File().InputPath().Dir().String())
		if err != nil {
			return nil
		}

		// composing builder's output path to be the same as the generated Go Protobuf is located
		index := strings.Index(protoFilePath, f.File().InputPath().Dir().String())
		if index == -1 {
			_, err = fmt.Fprintf(buf, "Something went wrong in searching for the output path to store generated builder file..")
			if err != nil {
				return nil
			}
		}
		protoFilePath = protoFilePath[index:]
		index = strings.Index(protoFilePath, "/")
		if index == -1 {
			_, err = fmt.Fprintf(buf, "Something went wrong in searching for the output path to store generated builder file..")
			if err != nil {
				return nil
			}
		}
		outputPath := protoFilePath[index+1:]
		_, err = fmt.Fprintf(buf, "Output file path is %v\nFile's Input path is %v\n", protoFilePath, f.File().InputPath().Dir().String())
		if err != nil {
			return nil
		}

		//Generating new .go file
		m.OverwriteGeneratorTemplateFile(outputPath+"/builder.go", templateBuilder.Lookup("builder.tpl"), bldr)
	}

	// ToDo - gathering data for pdubuilder
	pdubldr := pdubuilder{
		Imports:   "",
		Instances: make([]pdubuilderInstance, 0),
	}
	for _, f := range targets { // Input .proto files
		m.Push(f.Name().String()).Debug("reporting")
		// adding target file to import (all Protobuf files are linked to each other, so should be present in import)
		// if the dependency is not required, GoFmt() post-processor will take care of it
		// looking for a proto path here
		protoFilePath := lookUpProtoFilePath(dir, f.File().InputPath())
		packageName := adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String())
		pdubldr.Imports = pdubldr.Imports + "\n" + packageName + " \"" + protoFilePath + "\"" + "\n"

		for _, msg := range f.AllMessages() {
			_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
			if err != nil {
				return nil
			}

			// avoiding parsing constants
			if !strings.Contains(msg.SourceCodeInfo().LeadingComments(), "constant") {
				message := pdubuilderInstance{
					PackageName:        packageName,
					FunctionName:       doLinting(msg.Name().String()),
					FunctionOutputType: msg.Name().String(),
					Items:              make([]pdubuilderItem, 0),
				}
				// iterating over fields of the message
				for _, dep := range msg.Fields() {
					itemName := adjustFieldName(composeItemName(dep.Name().String()))
					itemType := adjustFieldName(extractItemMessageType(dep))

					item := pdubuilderItem{
						VariableName: strings.ToLower(itemName[:1]) + itemName[1:],
						FieldName:    itemName,
						ItemType:     itemType,
						IsChoice:     false,
						IsEnum:       false,
						IsList:       false,
					}

					// getting information about the item from the own Protobuf tree
					ie, ok := tree[itemType]
					if !ok {
						_, err = fmt.Fprintf(buf, "Couldn't find the message %v in the Protobuf tree\n", itemName)
						if err != nil {
							return nil
						}
					} else {

						// checking if the message is defined in the other Protobuf file
						_, err = fmt.Fprintf(buf, "Current package name is %v, item %v is from package %v\n",
							adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()), adjustFieldName(itemType), ie.PackageName)
						if err != nil {
							return nil
						}
						if ie.fromOtherProto(adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String())) && !isElementaryType(itemType) {
							itemType = "*" + ie.PackageName + "." + itemType
						} else if !isElementaryType(itemType) {
							itemType = "*" + packageName + "." + itemType
						}

						if ie.IsChoice {
							item.IsChoice = true
						} else if ie.IsList {
							item.IsList = true
						} else if ie.IsEnum {
							item.IsEnum = true
						}
					}

					message.Items = append(message.Items, item)
				}
				if len(message.Items) == 1 {
					message.SingleItem = true
				}
				pdubldr.Instances = append(pdubldr.Instances, message)
			}
		}
	}

	_, err = fmt.Fprintf(buf, "We're about to start generating encoder package\nObtained structure is %v\n", enc)
	if err != nil {
		return nil
	}

	//printing encoder package
	for _, e := range enc {
		_, err = fmt.Fprintf(buf, "Generating template for %v with name %v\n", e.MessageName, e.MessageNameInLogging)
		if err != nil {
			return nil
		}

		//Generating new .go file
		m.OverwriteGeneratorTemplateFile("encoder/"+e.MessageNameInLogging+".go", templateEncoder.Lookup("encoder.tpl"), e)
	}

	// printing pdubuilder package
	//Generating new .go file
	m.OverwriteGeneratorTemplateFile("pdubuilder/pdubuilder.go", templatePdubuilder.Lookup("pdubuilder.tpl"), pdubldr)

	if sm {
		_, err = fmt.Fprintf(buf, "We're about to start generating servicemodel package\nObtained structure is %v\n", smodel)
		if err != nil {
			return nil
		}
		//Generating new .go file
		m.OverwriteGeneratorTemplateFile("servicemodel/servicemodel.go", templateServicemodel.Lookup("servicemodel.tpl"), smodel)
	}

	out := m.OutputPath()
	_, err = fmt.Fprintf(buf, "Output path is\n%v\n", out)
	if err != nil {
		return nil
	}

	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)

	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func (m *builderInstance) doLinting() *builderInstance {

	m.FunctionName = doLinting(m.FunctionName)
	m.VariableName = doLinting(m.VariableName)
	m.VariableNamePtr = doLinting(m.VariableNamePtr)

	return m
}

//ToDo - extend linting
func doLinting(str string) string {

	res := strings.ReplaceAll(str, "Id", "ID")
	res = strings.ReplaceAll(res, "id", "ID")

	return res
}

func extractProtoFileName(proto string) string {

	if strings.LastIndex(proto, "/") != -1 {
		return proto[strings.LastIndex(proto, "/")+1:]
	}
	return proto
}

func extractPackageName(pckg string) string {

	if strings.Contains(pckg, "/") {
		return pckg[:strings.Index(pckg, "/")]
	}
	return pckg
}

func adjustProtoFileName(filename string) string {

	res := dashToUnderscore(filename)
	// space for future adjustments
	return res
}

func adjustPackageName(filename string, path string) string {

	// remove redundant patterns
	res := strings.ReplaceAll(filename, "_go", "")

	//extract version number
	index := strings.LastIndex(path, "/v")
	version := path[index+1:]

	// clarify if the version is not already present in the filename
	present := strings.Contains(res, version)

	//check if another versioning number presents in the naming - relevant for external dependencies
	re := regexp.MustCompile(`v\d{1}`)
	externalVersion := re.MatchString(res)

	if version != "" && !present && !externalVersion {
		res = res + version
	}

	//remove all underscores
	res = strings.ReplaceAll(res, "_", "")
	//remove all camel cases
	res = strings.ToLower(res)

	return res
}

func adjustMapVariableName(mapName string) string {

	flag := true
	for flag {
		index := strings.IndexAny(mapName, "_")
		if index == -1 {
			flag = false
		} else {
			// Assumption - string doesn't end with "_"
			mapName = mapName[:index] + strings.ToUpper(mapName[index+1:index+2]) + mapName[index+2:]
		}
	}
	mapName = strings.ReplaceAll(mapName, "Go", "")
	//ToDo - make a workaround through regexp
	//re := regexp.MustCompile(`v\d{1}`)
	//mapName = re.ReplaceAllString(mapName, "")
	mapName = strings.ReplaceAll(mapName, "V1", "")
	mapName = strings.ReplaceAll(mapName, "v1", "")
	mapName = strings.ReplaceAll(mapName, "V2", "")
	mapName = strings.ReplaceAll(mapName, "v2", "")
	mapName = strings.ReplaceAll(mapName, "V3", "")
	mapName = strings.ReplaceAll(mapName, "v3", "")
	mapName = strings.ReplaceAll(mapName, "V4", "")
	mapName = strings.ReplaceAll(mapName, "v4", "")

	return strings.ToUpper(mapName[:1]) + mapName[1:]
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}

func adjustMessageNameForLogging(name string) string {

	res := ""
	e2Name := adjustMapVariableName(extractPackageName(name))
	if strings.Contains(strings.ToLower(name), "e2sm") {
		tmp := "E2SM" + "-" + name[4:]
		res = strings.ReplaceAll(tmp, e2Name, strings.ToUpper(e2Name)+"-")
	} else if strings.Contains(strings.ToLower(name), "e2ap") {
		//ToDo - shouldn't be valid for E2AP - leaving for future
		tmp := "E2AP" + "-" + name[4:]
		res = strings.ReplaceAll(tmp, e2Name, strings.ToUpper(e2Name)+"-")
	}

	return res
}

func lookUpMessageParameters(comments string) string {

	res := ""
	if strings.Contains(comments, "aper:") {
		index1 := strings.Index(comments, "aper:\"")
		tmp := comments[index1+6:]
		index2 := strings.Index(tmp, "\"")
		res = tmp[:index2]
	}

	return res
}

func canonicalOrderingIsPresent(files []pgs.Message) bool {
	canonicalChoice := false
	// understanding if there is a canonical choice presence
	for _, msg := range files {
		for _, item := range msg.Fields() {
			if strings.Contains(item.SourceCodeInfo().LeadingComments(), "canonicalOrder") {
				canonicalChoice = true
				break
			}
		}
	}

	return canonicalChoice
}

func lookUpProtoFilePath(dir string, inputPath pgs.FilePath) string {

	targetPath := ""
	targetPath = inputPath.Dir().String()

	protoFilePath := ""
	err := filepath.Walk(dir,
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if strings.Contains(path, inputPath.BaseName()+".pb.go") && !strings.Contains(path, "/_") && strings.Contains(path, targetPath) {
				protoFilePath = path
			}

			return nil
		})
	if err != nil {
		return "Something went wrong in searching for the file path.."
	}

	if protoFilePath == "" {
		return "EmptyProtoFilePath"
	} else {
		//Composing protoFilePath to correspond to the correct input for Golang imports
		index := strings.Index(protoFilePath, "github.com/")
		if index == -1 {
			return "Something went wrong in searching for the file path for the import.."
		}
		protoFilePath = protoFilePath[index:]

		//Taking out file name from the path
		indexx := strings.LastIndex(protoFilePath, "/")
		if indexx == -1 {
			return "Something went wrong in searching for the file path for the import.."
		}
		protoFilePath = protoFilePath[:indexx]
	}

	return protoFilePath
}

func (sm *servicemodel) ParsePdu(messageName string) *servicemodel {

	if strings.Contains(strings.ToLower(messageName), "indicationheader") {
		sm.TopLevelPdus.IndicationHeader.IsPresent = true
		sm.TopLevelPdus.IndicationHeader.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "indicationmessage") {
		sm.TopLevelPdus.IndicationMessage.IsPresent = true
		sm.TopLevelPdus.IndicationMessage.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "controlheader") {
		sm.TopLevelPdus.ControlHeader.IsPresent = true
		sm.TopLevelPdus.ControlHeader.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "controlmessage") {
		sm.TopLevelPdus.ControlMessage.IsPresent = true
		sm.TopLevelPdus.ControlMessage.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "controloutcome") {
		sm.TopLevelPdus.ControlOutcome.IsPresent = true
		sm.TopLevelPdus.ControlOutcome.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "ranfunctiondescription") || strings.Contains(strings.ToLower(messageName), "ranfunctiondefinition") {
		sm.TopLevelPdus.RanFunctionDescription.IsPresent = true
		sm.TopLevelPdus.RanFunctionDescription.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "eventtriggerdefinition") || strings.Contains(strings.ToLower(messageName), "eventtrigger") {
		sm.TopLevelPdus.EventTriggerDefinition.IsPresent = true
		sm.TopLevelPdus.EventTriggerDefinition.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "actiondefinition") {
		sm.TopLevelPdus.ActionDefinition.IsPresent = true
		sm.TopLevelPdus.ActionDefinition.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "callprocessid") {
		sm.TopLevelPdus.CallProcessID.IsPresent = true
		sm.TopLevelPdus.CallProcessID.MessageProtoName = messageName
	}

	return sm
}

func (sm *servicemodel) ParseSmData(data []string) *servicemodel {

	for _, s := range data {
		if strings.Contains(s, "E2SM") {
			sm.E2SmName = extractSmName(s)
			sm.OID = extractOID(s)
			sm.SmVersion = extractVersion(s)
			sm.SmName = "e2sm" + strings.ToLower(sm.E2SmName) + strings.ToLower(sm.SmVersion)
			sm.PackageName = strings.ToTitle(strings.ToLower(sm.E2SmName)) + "ServiceModel"
			break
		}
	}

	return sm
}

func extractSmName(str string) string {

	res := ""
	index1 := strings.LastIndex(str, "E2SM-")
	tmp := str[index1+5:]
	index2 := strings.Index(tmp, "-")

	res = tmp[:index2]

	return res
}

func extractOID(str string) string {

	oid := ""
	start := strings.Index(str, "{")
	parse := str[start:]

	for i := 1; i <= 11; i++ {
		index1 := strings.Index(parse, "(")
		index2 := strings.Index(parse, ")")

		if i == 11 {
			oid = oid + parse[index1+1:index2]
		} else {
			oid = oid + parse[index1+1:index2] + "."
		}
		parse = parse[index2+1:]
	}

	return oid
}

func extractVersion(str string) string {

	version := ""

	start := strings.Index(str, "{")
	parse := str[start:]
	index := strings.Index(parse, "version")
	parse = parse[index:]

	index1 := strings.Index(parse, "(")
	index2 := strings.Index(parse, ")")

	version = "v" + parse[index1+1:index2]
	return version
}

func (sm *servicemodel) AddEncoderImport(str string) *servicemodel {

	index := strings.LastIndex(str, "/")
	str = str[:index]
	// finding version folder
	index = strings.LastIndex(str, "/")
	str = str[:index]

	sm.Imports = sm.Imports + "\"" + str + "/encoder\"\n"
	return sm
}

func composeItemName(str string) string {

	// making first letter a capital one
	res := strings.ToUpper(str[:1]) + str[1:]
	// making every next letter following after "_" a capital one
	i := 0
	for {
		i++
		index := strings.Index(res, "_")
		if index == -1 || i > 100 { // i > 100 is to avoid the case of infinite loops (if I forgot about something)
			break
		}
		res = res[:index] + strings.ToUpper(res[index+1:index+2]) + res[index+2:]
	}
	return res
}

// fromOtherProto returns name of the Protobuf package is the message is defined in other .proto than the reference Protobuf
func (m *protoItem) fromOtherProto(currentProto string) bool {

	if m.PackageName == currentProto {
		return true
	}

	return false
}

// fromOtherProto returns name of the Protobuf package is the message is defined in other .proto than the reference Protobuf
// if the message is from the same protobuf, then it returns empty string (ToDo - or maybe return something like "same")
func (m *protoItem) getImport() string {

	return m.PackageName + " \"" + m.ProtoFilePath + "\"\n"
}

// extractItemMessageType function extracts type of the filed, i.e., []byte, UeID or something else
func extractItemMessageType(message pgs.Field) string {

	res := ""

	if strings.Contains(message.Type().ProtoType().String(), "MESSAGE") {
		// ToDo - implement workaround of BitString
		if strings.Contains(message.Descriptor().GetTypeName(), "BitString") {
			res = "asn1.BitString"
		}
		index := strings.LastIndex(message.Descriptor().GetTypeName(), ".")
		if index != -1 {
			res = message.Descriptor().GetTypeName()[index+1:]
		}
	} else {
		// message is of basic type, i.e., []byte, bool, int32
		msgType := strings.ToLower(strings.ReplaceAll(message.Type().ProtoType().String(), "TYPE_", ""))
		switch msgType {
		case "enum":
			index := strings.LastIndex(message.Descriptor().GetTypeName(), ".")
			if index != -1 {
				res = message.Descriptor().GetTypeName()[index+1:]
			} else {
				res = "ErrorInParsing:" + msgType
			}
		case "bool":
			res = msgType
		case "int32":
			res = msgType
		case "int64":
			res = msgType
		case "float32":
			res = msgType
		case "float64":
			res = msgType
		case "bytes":
			res = "[]byte"
		case "string":
			res = msgType
		default:
			res = "ErrorInParsing:" + msgType
		}
	}

	return res
}

func isElementaryType(msgType string) bool {

	switch msgType {
	case "bool":
		return true
	case "int32":
		return true
	case "int64":
		return true
	case "float":
		return true
	case "[]byte":
		return true
	case "string":
		return true
	default:
		return false
	}
}

// this function mimics what Protobuf compiler does with the naming of the Messages, in particular puts in upper case next letter after the number
func adjustFieldName(str string) string {

	res := ""
	// flag to indicate whether the next character should be in uppercase
	toUpper := false
	for _, ch := range str {
		if toUpper {
			res = res + string(unicode.ToUpper(ch))
		} else {
			res = res + string(ch)
		}
		if unicode.IsDigit(ch) {
			toUpper = true
		} else {
			toUpper = false
		}
	}

	return res
}
