// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

package generic

import (
	"bytes"
	"fmt"
	pgs "github.com/lyft/protoc-gen-star"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

const moduleName = "builder"

var templateDir = os.Getenv("GOPATH")
var templateEncoder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/encoder.tpl")))

//var templatePdubuilder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/pdubuilder.tpl")))
//var templateBuilder = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/builder.tpl")))
var templateServicemodel = template.Must(template.ParseGlob(filepath.Join(templateDir, "src/github.com/onosproject/onos-e2-sm/protoc-gen-builder/templates/servicemodel.tpl")))

// encoder structure carries all necessary items to generate the encoder package
type encoder struct {
	Logger                  bool   // this is to indicate of logger was initialized - one structure should be randomly picked and assigned a logger flag
	Imports                 string // this is to hold all necessary imports, mainly the Protobuf which contains top-level PDUs (they're defined as PDUs with multiple formats wrapped as a nested CHOICE inside SEQUENCE)
	ProtoName               string // this is to hold ProtobufName to refer to the same package
	MessageName             string // top-level PDU message name
	MessageNameInLogging    string // this is to hold message name in the logs
	ChoiceMapName           string // this is to hold choice map name
	CanonicalChoiceMapName  string // this is to hold canonical choice map name
	CanonicalChoicePresence bool   // indicates whether Canonical ordering for choices is present and the map should be passed
	Parameters              string // this is to hold all necessary parameters to pass to the message - mostly it is "choiceExt" or "valueExt"
}

// servicemodel structure carries all necessary items to generate the servicemodel package
type servicemodel struct {
	PackageName  string
	E2SmName     string       // E2SM name without E2 prefix and in uppercase
	Imports      string       // this is to hold all necessary imports, mainly the Protobuf which contains top-level PDUs (they're defined as PDUs with multiple formats wrapped as a nested CHOICE inside SEQUENCE)
	SmName       string       // SM name composed of E2SmName and SmVersion variable both in lowercase
	SmVersion    string       // SM version
	OID          string       // SM OID
	TopLevelPdus topLevelPdus // this is to hold information about top-level PDUs
}

// topLevelPdus structure holds SM interface information for top-level PDUs
type topLevelPdus struct {
	IndicationHeader       topLevelPdu
	IndicationMessage      topLevelPdu
	ControlHeader          topLevelPdu
	ControlMessage         topLevelPdu
	ControlOutcome         topLevelPdu
	RanFunctionDescription topLevelPdu
	EventTriggerDefinition topLevelPdu
	ActionDefinition       topLevelPdu
	CallProcessID          topLevelPdu
}

type topLevelPdu struct {
	MessageProtoName string // this is to hold Protobuf name of the message
	IsPresent        bool   // this is to indicate if the PDU is present
}

// ToDo - find out how to handle pdubuilder package generation
//type pdubuilder struct {
//}

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
}

// NewModule configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{
		ModuleBase: &pgs.ModuleBase{},
	}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string {
	return moduleName
}

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}

	// firstly, understanding what to generate - servicemodel (E2SM) or E2AP
	sm, _ := m.Parameters().Bool("sm")

	dir, err := os.Getwd()
	// handle err
	if err != nil {
		return nil
	}
	//printFiles(path)
	_, err = fmt.Fprintf(buf, "Working directory is %v\n", dir)
	if err != nil {
		return nil
	}

	files, err := os.ReadDir(dir)
	if err != nil {
		return nil
	}
	for _, file := range files {
		_, err = fmt.Fprintf(buf, "Found file %v\n", file.Name())
		if err != nil {
			return nil
		}
	}

	// creating structure to generate encoder package
	enc := make([]encoder, 0)
	loggerPresence := true

	//creating structure to generate servicemodel package
	smodel := servicemodel{}

	if sm {
		smBasicInfoFilled := false
		for _, f := range targets { // Input .proto files

			_, err = fmt.Fprintf(buf, "Leading target comments were found, they are:\n%v\n", f.SourceCodeInfo().LeadingDetachedComments())
			if err != nil {
				return nil
			}

			// understanding if canonical choice ordering is present
			canonicalChoice := canonicalOrderingIsPresent(f.AllMessages())

			// looking for a proto path here
			protoFilePath := lookUpProtoFilePath(dir, f.File().InputPath())

			for _, msg := range f.AllMessages() {
				_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
				if err != nil {
					return nil
				}
				// This indicates us that we've found top-level message
				if strings.Contains(msg.Name().String(), "E2Sm") &&
					!strings.Contains(msg.Name().String(), "Format") && !strings.Contains(msg.Name().String(), "Item") {

					_, err = fmt.Fprintf(buf, "Top-level message was found!! It is %v\n", msg.Name().String())
					if err != nil {
						return nil
					}

					_, err = fmt.Fprintf(buf, "Comments were found, they are:\n%v\n", msg.SourceCodeInfo().LeadingComments())
					if err != nil {
						return nil
					}

					pdu := encoder{
						ProtoName:               adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()),
						MessageName:             msg.Name().String(),
						MessageNameInLogging:    adjustMessageNameForLogging(msg.Name().String()),
						ChoiceMapName:           adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "Choicemap",
						CanonicalChoiceMapName:  adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "CanonicalChoicemap",
						CanonicalChoicePresence: canonicalChoice,
						Parameters:              lookUpMessageParameters(msg.SourceCodeInfo().LeadingComments()),
					}
					if loggerPresence {
						pdu.Logger = true
						loggerPresence = false
					} else {
						pdu.Logger = false
					}
					pdu.Imports = pdu.ProtoName + " \"" + protoFilePath + "\"" + "\n"
					enc = append(enc, pdu)

					// filling in some information about SM
					smodel.ParsePdu(msg.Name().String())
					if !smBasicInfoFilled {
						smodel.ParseSmData(f.SourceCodeInfo().LeadingDetachedComments())
						smodel.Imports = smodel.SmName + " \"" + protoFilePath + "\"" + "\n"
						smodel.AddEncoderImport(protoFilePath)
						smBasicInfoFilled = true
					}
				}
			}
		}
	} else {
		// There is only single top-level PDU so far, but leaving it here for future
		for _, f := range targets { // Input .proto files

			// understanding if canonical choice ordering is present
			canonicalChoice := canonicalOrderingIsPresent(f.AllMessages())

			// looking for a proto path here
			protoFilePath := lookUpProtoFilePath(dir, f.File().InputPath())

			for _, msg := range f.AllMessages() {
				_, err = fmt.Fprintf(buf, "Message name is %v\n", msg.Name().String())
				if err != nil {
					return nil
				}
				// This indicates us that we've found top-level message
				if strings.Contains(msg.Name().String(), "E2ApPdu") &&
					!strings.Contains(msg.Name().String(), "Format") && !strings.Contains(msg.Name().String(), "Item") {

					_, err = fmt.Fprintf(buf, "Top-level message was found!! It is %v\n", msg.Name().String())
					if err != nil {
						return nil
					}
					// Stick to the E2AP message
					pdu := encoder{
						Logger:                  true,
						ProtoName:               adjustPackageName(adjustProtoFileName(extractProtoFileName(f.Name().Split()[0])), f.File().InputPath().Dir().String()),
						MessageName:             msg.Name().String(),
						MessageNameInLogging:    "E2AP",
						ChoiceMapName:           adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "Choicemap",
						CanonicalChoiceMapName:  adjustMapVariableName(extractPackageName(f.Name().Split()[0])) + "CanonicalChoicemap",
						CanonicalChoicePresence: canonicalChoice,
						Parameters:              lookUpMessageParameters(msg.SourceCodeInfo().LeadingComments()),
					}
					pdu.Imports = pdu.ProtoName + " \"" + protoFilePath + "\"" + "\n"
					enc = append(enc, pdu)
				}
			}
		}
	}

	_, err = fmt.Fprintf(buf, "We're about to start generating encoder package\nObtained structure is %v\n", enc)
	if err != nil {
		return nil
	}

	//printing encoder package
	for _, e := range enc {
		_, err = fmt.Fprintf(buf, "Generating template for %v with name %v\n", e.MessageName, e.MessageNameInLogging)
		if err != nil {
			return nil
		}

		//Generating new .go file
		m.OverwriteGeneratorTemplateFile(e.MessageNameInLogging+".go", templateEncoder.Lookup("encoder.tpl"), e)
	}

	if sm {
		_, err = fmt.Fprintf(buf, "We're about to start generating servicemodel package\nObtained structure is %v\n", smodel)
		if err != nil {
			return nil
		}
		//Generating new .go file
		m.OverwriteGeneratorTemplateFile("servicemodel.go", templateServicemodel.Lookup("servicemodel.tpl"), smodel)
	}

	out := m.OutputPath()
	_, err = fmt.Fprintf(buf, "Output path is\n%v\n", out)
	if err != nil {
		return nil
	}

	m.OverwriteCustomFile(
		"/tmp/report.txt",
		buf.String(),
		0644,
	)

	return m.Artifacts()
}

/////////////////////////////////
/// Here is necessary tooling ///
/////////////////////////////////

func extractProtoFileName(proto string) string {

	if strings.LastIndex(proto, "/") != -1 {
		return proto[strings.LastIndex(proto, "/")+1:]
	}
	return proto
}

func extractPackageName(pckg string) string {

	if strings.Contains(pckg, "/") {
		return pckg[:strings.Index(pckg, "/")]
	}
	return pckg
}

func adjustProtoFileName(filename string) string {

	res := dashToUnderscore(filename)
	// space for future adjustments
	return res
}

func adjustPackageName(filename string, path string) string {

	// remove redundant patterns
	res := strings.ReplaceAll(filename, "_go", "")

	//extract version number
	index := strings.LastIndex(path, "/v")
	version := path[index+1:]

	// clarify if the version is not already present in the filename
	present := strings.Contains(res, version)

	//check if another versioning number presents in the naming - relevant for external dependencies
	re := regexp.MustCompile(`v\d{1}`)
	externalVersion := re.MatchString(res)

	if version != "" && !present && !externalVersion {
		res = res + version
	}

	//remove all underscores
	res = strings.ReplaceAll(res, "_", "")
	//remove all camel cases
	res = strings.ToLower(res)

	return res
}

func adjustMapVariableName(mapName string) string {

	flag := true
	for flag {
		index := strings.IndexAny(mapName, "_")
		if index == -1 {
			flag = false
		} else {
			// Assumption - string doesn't end with "_"
			mapName = mapName[:index] + strings.ToUpper(mapName[index+1:index+2]) + mapName[index+2:]
		}
	}
	mapName = strings.ReplaceAll(mapName, "Go", "")
	//ToDo - make a workaround through regexp
	//re := regexp.MustCompile(`v\d{1}`)
	//mapName = re.ReplaceAllString(mapName, "")
	mapName = strings.ReplaceAll(mapName, "V1", "")
	mapName = strings.ReplaceAll(mapName, "v1", "")
	mapName = strings.ReplaceAll(mapName, "V2", "")
	mapName = strings.ReplaceAll(mapName, "v2", "")
	mapName = strings.ReplaceAll(mapName, "V3", "")
	mapName = strings.ReplaceAll(mapName, "v3", "")
	mapName = strings.ReplaceAll(mapName, "V4", "")
	mapName = strings.ReplaceAll(mapName, "v4", "")

	return strings.ToUpper(mapName[:1]) + mapName[1:]
}

func dashToUnderscore(str string) string {

	return strings.ReplaceAll(str, "-", "_")
}

func adjustMessageNameForLogging(name string) string {

	res := ""
	e2Name := adjustMapVariableName(extractPackageName(name))
	if strings.Contains(strings.ToLower(name), "e2sm") {
		tmp := "E2SM" + "-" + name[4:]
		res = strings.ReplaceAll(tmp, e2Name, strings.ToUpper(e2Name)+"-")
	} else if strings.Contains(strings.ToLower(name), "e2ap") {
		//ToDo - shouldn't be valid for E2AP - leaving for future
		tmp := "E2AP" + "-" + name[4:]
		res = strings.ReplaceAll(tmp, e2Name, strings.ToUpper(e2Name)+"-")
	}

	return res
}

func lookUpMessageParameters(comments string) string {

	res := ""
	if strings.Contains(comments, "aper:") {
		index1 := strings.Index(comments, "aper:\"")
		tmp := comments[index1+6:]
		index2 := strings.Index(tmp, "\"")
		res = tmp[:index2]
	}

	return res
}

func canonicalOrderingIsPresent(files []pgs.Message) bool {
	canonicalChoice := false
	// understanding if there is a canonical choice presence
	for _, msg := range files {
		for _, item := range msg.Fields() {
			if strings.Contains(item.SourceCodeInfo().LeadingComments(), "canonicalOrder") {
				canonicalChoice = true
				break
			}
		}
	}

	return canonicalChoice
}

func lookUpProtoFilePath(dir string, inputPath pgs.FilePath) string {

	targetPath := ""
	targetPath = inputPath.Dir().String()

	protoFilePath := ""
	err := filepath.Walk(dir,
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if strings.Contains(path, inputPath.BaseName()+".pb.go") && !strings.Contains(path, "/_") && strings.Contains(path, targetPath) {
				protoFilePath = path
			}

			return nil
		})
	if err != nil {
		return "Something went wrong in searching for the file path.."
	}

	if protoFilePath == "" {
		return "EmptyProtoFilePath"
	} else {
		//Composing protoFilePath to correspond to the correct input for Golang imports
		index := strings.Index(protoFilePath, "github.com/")
		if index == -1 {
			return "Something went wrong in searching for the file path for the import.."
		}
		protoFilePath = protoFilePath[index:]

		//Taking out file name from the path
		indexx := strings.LastIndex(protoFilePath, "/")
		if indexx == -1 {
			return "Something went wrong in searching for the file path for the import.."
		}
		protoFilePath = protoFilePath[:indexx]
	}

	return protoFilePath
}

func (sm *servicemodel) ParsePdu(messageName string) *servicemodel {

	if strings.Contains(strings.ToLower(messageName), "indicationheader") {
		sm.TopLevelPdus.IndicationHeader.IsPresent = true
		sm.TopLevelPdus.IndicationHeader.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "indicationmessage") {
		sm.TopLevelPdus.IndicationMessage.IsPresent = true
		sm.TopLevelPdus.IndicationMessage.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "controlheader") {
		sm.TopLevelPdus.ControlHeader.IsPresent = true
		sm.TopLevelPdus.ControlHeader.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "controlmessage") {
		sm.TopLevelPdus.ControlMessage.IsPresent = true
		sm.TopLevelPdus.ControlMessage.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "controloutcome") {
		sm.TopLevelPdus.ControlOutcome.IsPresent = true
		sm.TopLevelPdus.ControlOutcome.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "ranfunctiondescription") || strings.Contains(strings.ToLower(messageName), "ranfunctiondefinition") {
		sm.TopLevelPdus.RanFunctionDescription.IsPresent = true
		sm.TopLevelPdus.RanFunctionDescription.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "eventtriggerdefinition") || strings.Contains(strings.ToLower(messageName), "eventtrigger") {
		sm.TopLevelPdus.EventTriggerDefinition.IsPresent = true
		sm.TopLevelPdus.EventTriggerDefinition.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "actiondefinition") {
		sm.TopLevelPdus.ActionDefinition.IsPresent = true
		sm.TopLevelPdus.ActionDefinition.MessageProtoName = messageName
	}
	if strings.Contains(strings.ToLower(messageName), "callprocessid") {
		sm.TopLevelPdus.CallProcessID.IsPresent = true
		sm.TopLevelPdus.CallProcessID.MessageProtoName = messageName
	}

	return sm
}

func (sm *servicemodel) ParseSmData(data []string) *servicemodel {

	for _, s := range data {
		if strings.Contains(s, "E2SM") {
			sm.E2SmName = extractSmName(s)
			sm.OID = extractOID(s)
			sm.SmVersion = extractVersion(s)
			sm.SmName = "e2sm" + strings.ToLower(sm.E2SmName) + strings.ToLower(sm.SmVersion)
			sm.PackageName = strings.ToTitle(strings.ToLower(sm.E2SmName)) + "ServiceModel"
			break
		}
	}

	return sm
}

func extractSmName(str string) string {

	res := ""
	index1 := strings.LastIndex(str, "E2SM-")
	tmp := str[index1+5:]
	index2 := strings.Index(tmp, "-")

	res = tmp[:index2]

	return res
}

func extractOID(str string) string {

	oid := ""
	start := strings.Index(str, "{")
	parse := str[start:]

	for i := 1; i <= 10; i++ {
		index1 := strings.Index(parse, "(")
		index2 := strings.Index(parse, ")")

		if i == 10 {
			oid = oid + parse[index1+1:index2]
		} else {
			oid = oid + parse[index1+1:index2] + "."
		}
		parse = parse[index2+1:]
	}

	return oid
}

func extractVersion(str string) string {

	version := ""

	start := strings.Index(str, "{")
	parse := str[start:]
	index := strings.Index(parse, "version")
	parse = parse[index:]

	index1 := strings.Index(parse, "(")
	index2 := strings.Index(parse, ")")

	version = "v" + parse[index1+1:index2]
	return version
}

func (sm *servicemodel) AddEncoderImport(str string) *servicemodel {

	index := strings.LastIndex(str, "/")
	str = str[:index]
	// finding version folder
	index = strings.LastIndex(str, "/")
	str = str[:index]

	sm.Imports = sm.Imports + "\"" + str + "/encoder\"\n"
	return sm
}
